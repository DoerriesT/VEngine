#version 450

#define DEPTH_TEXTURE_INDEX 0
#define ALBEDO_TEXTURE_INDEX 1
#define NORMAL_TEXTURE_INDEX 2
#define MRO_TEXTURE_INDEX 3

#include "common.h"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform PushConsts 
{
	uint directionalLightCount;
} uPushConsts;

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a2 = roughness*roughness;
    a2 *= a2;
    float NdotH2 = max(dot(N, H), 0.0);
    NdotH2 *= NdotH2;

    float nom   = a2;
    float denom = NdotH2 * (a2 - 1.0) + 1.0;

    denom = PI * denom * denom;

    return nom / max(denom, 0.0000001);
}

float GeometrySmith(float NdotV, float NdotL, float roughness)
{
	float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float ggx2 =  NdotV / max(NdotV * (1.0 - k) + k, 0.0000001);
    float ggx1 = NdotL / max(NdotL * (1.0 - k) + k, 0.0000001);

    return ggx1 * ggx2;
}


vec3 fresnelSchlick(float HdotV, vec3 F0)
{
	float power = (-5.55473 * HdotV - 6.98316) * HdotV;
	return F0 + (1.0 - F0) * pow(2.0, power);
}

float interleavedGradientNoise(vec2 v)
{
	vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
	return fract(magic.z * dot(v, magic.xy));
}

float smoothDistanceAtt(float squaredDistance, float invSqrAttRadius)
{
	float factor = squaredDistance * invSqrAttRadius;
	float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);
	return smoothFactor * smoothFactor;
}

float getDistanceAtt(vec3 unnormalizedLightVector, float invSqrAttRadius)
{
	float sqrDist = dot(unnormalizedLightVector, unnormalizedLightVector);
	float attenuation = 1.0 / (max(sqrDist, invSqrAttRadius));
	attenuation *= smoothDistanceAtt(sqrDist, invSqrAttRadius);
	
	return attenuation;
}

vec3 evaluatePointLight(
	inout mat3 viewMatrix,
	inout vec3 albedo, 
	inout vec3 N, 
	inout vec3 F0, 
	inout vec3 V,
	inout vec3 viewSpacePosition,
	inout float NdotV,
	inout float metallic, 
	inout float roughness,
	uint index)
{
	vec4 positionRadius = uPointLightData.lights[index].positionRadius;
	vec3 unnormalizedLightVector = positionRadius.xyz - viewSpacePosition;
	vec3 L = normalize(unnormalizedLightVector);
	float att = getDistanceAtt(unnormalizedLightVector, uPointLightData.lights[index].colorInvSqrAttRadius.w);

	vec3 H = normalize(V + L);
	float NdotL = max(dot(N, L), 0.0);

	// Cook-Torrance BRDF
	float NDF = DistributionGGX(N, H, roughness);
	float G = GeometrySmith(NdotV, NdotL, roughness);
	vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);

	vec3 numerator = NDF * G * F;
	float denominator = max(4 * NdotV * NdotL, 0.0000001);

	vec3 specular = numerator / denominator;

	// because of energy conversion kD and kS must add up to 1.0
	vec3 kD = vec3(1.0) - F;
	// multiply kD by the inverse metalness so if a material is metallic, it has no diffuse lighting (and otherwise a blend)
	kD *= 1.0 - metallic;

	vec3 radiance = uPointLightData.lights[index].colorInvSqrAttRadius.rgb * att;
	return (kD * albedo * (1.0 / PI) + specular) * radiance * NdotL;
}

vec3 evaluateDirectionalLight(
	inout mat3 viewMatrix,
	inout vec3 albedo, 
	inout vec3 N, 
	inout vec3 F0, 
	inout vec3 V,
	inout vec3 viewSpacePosition,
	inout float NdotV,
	inout float metallic, 
	inout float roughness,
	uint index)
{
	vec3 L = viewMatrix * uDirectionalLightData.lights[index].direction.xyz;
	vec3 H = normalize(V + L);
    
	float NdotL = max(dot(N, L), 0.0);
	
	float NDF = DistributionGGX(N, H, roughness);
	float G = GeometrySmith(NdotV, NdotL, roughness);
	vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    
	vec3 numerator = NDF * G * F;
	float denominator = max(4 * NdotV * NdotL, 0.0000001);
    
	vec3 specular = numerator / denominator;
    
	// because of energy conversion kD and kS must add up to 1.0
	vec3 kD = vec3(1.0) - F;
	// multiply kD by the inverse metalness so if a material is metallic, it has no diffuse lighting (and otherwise a blend)
	kD *= 1.0 - metallic;
    
	vec3 result = (kD * albedo * (1.0 / PI) + specular) * NdotL * uDirectionalLightData.lights[index].color.rgb;
	
	uint shadowDataCount = uDirectionalLightData.lights[index].shadowDataCount;
	if(shadowDataCount > 0)
	{		
		uint shadowDataOffset = uDirectionalLightData.lights[index].shadowDataOffset;
		vec3 shadowCoord = vec3(2.0);
		vec2 invShadowTextureSize = 1.0 / textureSize(uShadowTexture, 0).xy;
		vec4 offsetPos = uPerFrameData.invViewMatrix * vec4(0.1 * L + viewSpacePosition, 1.0);

		uint split = 0;
		for (; split < shadowDataCount; ++split)
		{
			const vec4 projCoords4 = 
			uShadowData.data[shadowDataOffset + split].shadowViewProjectionMatrix * offsetPos;
			shadowCoord = (projCoords4.xyz / projCoords4.w);
			shadowCoord.xy = shadowCoord.xy * 0.5 + 0.5; 
			
			// test if projected coordinate is inside texture
			// add small guard band at edges to avoid PCF sampling outside texture
			if(all(greaterThanEqual(shadowCoord.xy, vec2(0.003))) && all(lessThan(shadowCoord.xy, vec2(1.0 - 0.003))))
			{
				vec4 scaleBias = uShadowData.data[shadowDataOffset + split].shadowCoordScaleBias;
				shadowCoord.xy = shadowCoord.xy * scaleBias.xy + scaleBias.zw;
				break;
			}
		}

		
		float shadow = 0.0;
		
		const float noise = interleavedGradientNoise(vec2(gl_GlobalInvocationID.xy));// * 0.5 + (uOddFrame ? 0.5 : 0.0);

		const float rotSin = sin(2.0 * PI * noise);
		const float rotCos = cos(2.0 * PI * noise);

		const mat2 rotation = mat2(rotCos, rotSin, -rotSin, rotCos);

		const vec2 samples[8] = 
		{ 
			vec2(-0.7071, 0.7071),
			vec2(0.0, -0.8750),
			vec2(0.5303, 0.5303),
			vec2(-0.625, 0.0),
			vec2(0.3536, -0.3536),
			vec2(0.0, 0.375),
			vec2(-0.1768, -0.1768),
			vec2(0.125, 0.0)
		};

		const float splitMult = split == 0 ? 5.0 : split == 1 ? 2.0 : 1.0;

		for(int i = 0; i < 8; ++i)
		{
			vec2 offset = rotation * samples[i];
			shadow += texture(uShadowTexture, vec3(shadowCoord.xy + offset * invShadowTextureSize * splitMult, shadowCoord.z)).x;
		}
		shadow *= 1.0 / 8.0;
		
		result *= (1.0 - shadow);
	}
	return result;
}

vec3 accurateLinearToSRGB(in vec3 linearCol)
{
	vec3 sRGBLo = linearCol * 12.92;
	vec3 sRGBHi = (pow(abs(linearCol), vec3(1.0/2.4)) * 1.055) - 0.055;
	vec3 sRGB = mix(sRGBLo, sRGBHi, vec3(greaterThan(linearCol, vec3(0.0031308))));
	return sRGB;
}

vec3 accurateSRGBToLinear(in vec3 sRGBCol)
{
	vec3 linearRGBLo = sRGBCol * (1.0 / 12.92);
	vec3 linearRGBHi = pow((sRGBCol + vec3(0.055)) * vec3(1.0 / 1.055), vec3(2.4));
	vec3 linearRGB = mix(linearRGBLo, linearRGBHi, vec3(greaterThan(sRGBCol, vec3(0.04045))));
	return linearRGB;
}

uint getTileAddress()
{
	uvec2 tile = uvec2(gl_GlobalInvocationID.xy) / TILE_SIZE;
	uint domainSizeX = uint(textureSize(uGBufferTextures[0], 0).x);
	return tile.x + tile.y * (domainSizeX / TILE_SIZE + ((domainSizeX % TILE_SIZE == 0) ? 0 : 1));
}

const vec3 kRadarColors[14] = 
{
    {0,0.9255,0.9255},   // cyan
    {0,0.62745,0.9647},  // light blue
    {0,0,0.9647},        // blue
    {0,1,0},             // bright green
    {0,0.7843,0},        // green
    {0,0.5647,0},        // dark green
    {1,1,0},             // yellow
    {0.90588,0.75294,0}, // yellow-orange
    {1,0.5647,0},        // orange
    {1,0,0},             // bright red
    {0.8392,0,0},        // red
    {0.75294,0,0},       // dark red
    {1,0,1},             // magenta
    {0.6,0.3333,0.7882}, // purple
};

vec3 convertNumberOfLightsToRadarColor(uint nNumLightsInThisTile, uint uMaxNumLightsPerTile)
{
    // black for no lights
    if( nNumLightsInThisTile == 0 ) return vec3(0.0);
    // light purple for reaching the max
    else if( nNumLightsInThisTile == uMaxNumLightsPerTile ) return vec3(0.847,0.745,0.921);
    // white for going over the max
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return vec3(1.0);
    // else use weather radar colors
    else
    {
        // use a log scale to provide more detail when the number of lights is smaller

        // want to find the base b such that the logb of uMaxNumLightsPerTile is 14
        // (because we have 14 radar colors)
        float fLogBase = exp2(0.07142857f*log2(float(uMaxNumLightsPerTile)));

        // change of base
        // logb(x) = log2(x) / log2(b)
        uint nColorIndex = uint(floor(log2(float(nNumLightsInThisTile)) / log2(fLogBase)));
        return kRadarColors[nColorIndex];
    }
}

void main() 
{
	float depth = texelFetch(uGBufferTextures[DEPTH_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).x;
	
	if (depth == 1.0)
	{
		imageStore(uLightingResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(0.529, 0.808, 0.922), 1.0));
		return;
	}
	
	vec2 domainSize = textureSize(uGBufferTextures[0], 0).xy;
	vec2 texelSize = vec2(1.0 / domainSize);
	vec2 texCoord = vec2(vec2(gl_GlobalInvocationID.xy) + 0.5) * texelSize;
	const vec4 clipSpacePosition = vec4(vec2(texCoord) * 2.0 - 1.0, depth, 1.0);
	vec4 viewSpacePosition = uPerFrameData.invProjectionMatrix * clipSpacePosition;
	viewSpacePosition /= viewSpacePosition.w;
	
	mat3 viewMatrix = mat3(uPerFrameData.viewMatrix);
	vec3 albedo = accurateSRGBToLinear(texelFetch(uGBufferTextures[ALBEDO_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).rgb);
	vec3 N = texelFetch(uGBufferTextures[NORMAL_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).xyz;
	float metallic = texelFetch(uGBufferTextures[MRO_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).x;
	vec3 F0 = mix(vec3(0.04), albedo, metallic);
	vec3 V = -normalize(viewSpacePosition.xyz);
	float NdotV = max(dot(N, V), 0.0);
	float roughness = texelFetch(uGBufferTextures[MRO_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).y;
	
	vec3 result = vec3(0.0);
	
	// ambient
	result += 0.1 * albedo;
	
	// directional lights
	for (uint i = 0; i < uPushConsts.directionalLightCount; ++i)
	{
		result += evaluateDirectionalLight(viewMatrix, albedo, N, F0, V, viewSpacePosition.xyz, NdotV, metallic, roughness, i);
	}
	
	// point lights
	{
		uint wordMin = 0;
		uint wordMax = MAX_POINT_LIGHT_WORDS - 1;
		
		uint address = getTileAddress() * MAX_POINT_LIGHT_WORDS;
		uint zBinAddress = clamp(uint(floor(-viewSpacePosition.z)), 0, 8191);
		uint zBinData = uPointLightZBins.bins[zBinAddress];
		uint minIndex = (zBinData & 0xFFFF0000) >> 16;
		uint maxIndex = zBinData & 0xFFFF;
		wordMin = minIndex / 32;
		wordMax = maxIndex / 32;
		
		uint count = 0;
		for (uint wordIndex = wordMin; wordIndex <= wordMax; ++wordIndex)
		{
			uint mask = uPointLightBitMask.mask[address + wordIndex];
			
			while (mask != 0)
			{
				uint bitIndex = findLSB(mask);
				uint index = 32 * wordIndex + bitIndex;
				mask ^= (1 << bitIndex);
				if (index >= minIndex && index <= maxIndex)
				{
					result += evaluatePointLight(viewMatrix, albedo, N, F0, V, viewSpacePosition.xyz, NdotV, metallic, roughness, index);
				}
				++count;
			}
		}
	}
	
	result = accurateLinearToSRGB(result);
	//result = mix(convertNumberOfLightsToRadarColor(count, 144), result, 0.5);
	imageStore(uLightingResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1.0));
}