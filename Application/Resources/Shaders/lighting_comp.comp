#version 450

#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

#include "lighting_bindings.h"

layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING, rgba16f) uniform writeonly image2D uLightingResultImage;
layout(set = GBUFFER_IMAGES_SET, binding = GBUFFER_IMAGES_BINDING) uniform sampler2D uGBufferTextures[4];
layout(set = SHADOW_ATLAS_SET, binding = SHADOW_ATLAS_BINDING) uniform sampler2DShadow uShadowTexture;

layout(set = DIRECTIONAL_LIGHT_DATA_SET, binding = DIRECTIONAL_LIGHT_DATA_BINDING) readonly buffer DIRECTIONAL_LIGHT_DATA
{
	DirectionalLightData uDirectionalLightData[];
};

layout(set = POINT_LIGHT_DATA_SET, binding = POINT_LIGHT_DATA_BINDING) readonly buffer POINT_LIGHT_DATA
{
	PointLightData uPointLightData[];
};

layout(set = SHADOW_DATA_SET, binding = SHADOW_DATA_BINDING) readonly buffer SHADOW_DATA
{
	ShadowData uShadowData[];
};

layout(set = POINT_LIGHT_Z_BINS_SET, binding = POINT_LIGHT_Z_BINS_BINDING) readonly buffer POINT_LIGHT_Z_BINS
{
	uint uPointLightZBins[];
};

layout(set = POINT_LIGHT_MASK_SET, binding = POINT_LIGHT_MASK_BINDING) readonly buffer POINT_LIGHT_BITMASK 
{
	uint uPointLightBitMask[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "commonLighting.h"

const vec3 kRadarColors[14] = 
{
    {0,0.9255,0.9255},   // cyan
    {0,0.62745,0.9647},  // light blue
    {0,0,0.9647},        // blue
    {0,1,0},             // bright green
    {0,0.7843,0},        // green
    {0,0.5647,0},        // dark green
    {1,1,0},             // yellow
    {0.90588,0.75294,0}, // yellow-orange
    {1,0.5647,0},        // orange
    {1,0,0},             // bright red
    {0.8392,0,0},        // red
    {0.75294,0,0},       // dark red
    {1,0,1},             // magenta
    {0.6,0.3333,0.7882}, // purple
};

vec3 convertNumberOfLightsToRadarColor(uint nNumLightsInThisTile, uint uMaxNumLightsPerTile)
{
    // black for no lights
    if( nNumLightsInThisTile == 0 ) return vec3(0.0);
    // light purple for reaching the max
    else if( nNumLightsInThisTile == uMaxNumLightsPerTile ) return vec3(0.847,0.745,0.921);
    // white for going over the max
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return vec3(1.0);
    // else use weather radar colors
    else
    {
        // use a log scale to provide more detail when the number of lights is smaller

        // want to find the base b such that the logb of uMaxNumLightsPerTile is 14
        // (because we have 14 radar colors)
        float fLogBase = exp2(0.07142857f*log2(float(uMaxNumLightsPerTile)));

        // change of base
        // logb(x) = log2(x) / log2(b)
        uint nColorIndex = uint(floor(log2(float(nNumLightsInThisTile)) / log2(fLogBase)));
        return kRadarColors[nColorIndex];
    }
}

void main() 
{
	const float depth = texelFetch(uGBufferTextures[DEPTH_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).x;
	
	if (depth == 1.0)
	{
		imageStore(uLightingResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(0.529, 0.808, 0.922), 1.0));
		return;
	}
	
	const vec2 domainSize = textureSize(uGBufferTextures[0], 0).xy;
	const vec2 texelSize = vec2(1.0 / domainSize);
	const vec2 texCoord = vec2(vec2(gl_GlobalInvocationID.xy) + 0.5) * texelSize;
	const vec4 clipSpacePosition = vec4(vec2(texCoord) * 2.0 - 1.0, depth, 1.0);
	vec4 viewSpacePosition = uPushConsts.invJitteredProjectionMatrix * clipSpacePosition;
	viewSpacePosition /= viewSpacePosition.w;
	
	const vec2 metalnessRoughness = texelFetch(uGBufferTextures[MRO_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).xy;
	
	LightingParams lightingParams;
	lightingParams.albedo = accurateSRGBToLinear(texelFetch(uGBufferTextures[ALBEDO_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).rgb);
	lightingParams.N = texelFetch(uGBufferTextures[NORMAL_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).xyz;
	lightingParams.V = -normalize(viewSpacePosition.xyz);
	lightingParams.viewSpacePosition = viewSpacePosition.xyz;
	lightingParams.metalness = metalnessRoughness.x;
	lightingParams.roughness = metalnessRoughness.y;
	
	vec3 result = vec3(0.0);
	
	// ambient
	result += 1.0 * lightingParams.albedo;
	
	const vec2 pixelCoord = vec2(gl_GlobalInvocationID.xy) + 0.5;
	const mat4 invViewMatrix = transpose(mat4(uPushConsts.invViewMatrixRow0,
												uPushConsts.invViewMatrixRow1,
												uPushConsts.invViewMatrixRow2,
												vec4(0.0, 0.0, 0.0, 1.0)));
	
	// directional lights
	for (uint i = 0; i < uPushConsts.directionalLightCount; ++i)
	{
		const DirectionalLightData directionalLightData = uDirectionalLightData[i];
		const vec3 contribution = evaluateDirectionalLight(lightingParams, directionalLightData);
		const float shadow = directionalLightData.shadowDataCount > 0 ?
			evaluateDirectionalLightShadow(directionalLightData, uShadowTexture, invViewMatrix, lightingParams.viewSpacePosition, pixelCoord)
			: 0.0;
		
		result += contribution * (1.0 - shadow);
	}
	
	// point lights
	if (uPushConsts.pointLightCount > 0)
	{
		uint wordMin = 0;
		const uint wordCount = (uPushConsts.pointLightCount + 31) / 32;
		uint wordMax = wordCount - 1;
		
		const uint zBinAddress = clamp(uint(floor(-viewSpacePosition.z)), 0, 8191);
		const uint zBinData = uPointLightZBins[zBinAddress];
		const uint minIndex = (zBinData & uint(0xFFFF0000)) >> 16;
		const uint maxIndex = zBinData & uint(0xFFFF);
		// mergedMin scalar from this point
		const uint mergedMin = subgroupBroadcastFirst(subgroupMin(minIndex)); 
		// mergedMax scalar from this point
		const uint mergedMax = subgroupBroadcastFirst(subgroupMax(maxIndex)); 
		wordMin = max(mergedMin / 32, wordMin);
		wordMax = min(mergedMax / 32, wordMax);
		const uint address = getTileAddress(uvec2(gl_GlobalInvocationID.xy), uint(textureSize(uGBufferTextures[0], 0).x), wordCount);
		
		for (uint wordIndex = wordMin; wordIndex <= wordMax; ++wordIndex)
		{
			uint mask = uPointLightBitMask[address + wordIndex];
			
			// mask by zbin mask
			const int localBaseIndex = int(wordIndex * 32);
			const uint localMin = clamp(int(minIndex) - localBaseIndex, 0, 31);
			const uint localMax = clamp(int(maxIndex) - localBaseIndex, 0, 31);
			const uint maskWidth = localMax - localMin + 1;
			const uint zBinMask = (maskWidth == 32) ? uint(0xFFFFFFFF) : (((1 << maskWidth) - 1) << localMin);
			mask &= zBinMask;
			
			// compact word bitmask over all threads in subrgroup
			uint mergedMask = subgroupBroadcastFirst(subgroupOr(mask));
			
			while (mergedMask != 0)
			{
				const uint bitIndex = findLSB(mergedMask);
				const uint index = 32 * wordIndex + bitIndex;
				mergedMask ^= (1 << bitIndex);
				result += evaluatePointLight(lightingParams, uPointLightData[index]);
			}
		}
	}

	imageStore(uLightingResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1.0));
}