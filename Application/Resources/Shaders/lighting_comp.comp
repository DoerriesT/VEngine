#version 450

#ifndef PI
#define PI (3.14159265359)
#endif // PI

#define DEPTH_TEXTURE_INDEX 0
#define ALBEDO_TEXTURE_INDEX 1
#define NORMAL_TEXTURE_INDEX 2
#define MRO_TEXTURE_INDEX 3
#define MAX_POINT_LIGHT_WORDS 2048
#define MAX_SPOT_LIGHT_WORDS 2048
#define TILE_SIZE 16

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform writeonly image2D uResultImage;

layout(set = 0, binding = 1) uniform sampler2D uTextures[4];

layout(set = 1, binding = 0) uniform PerFrameData 
{
	float time;
	float fovy;
	float nearPlane;
	float farPlane;
	mat4 viewMatrix;
	mat4 projectionMatrix;
	mat4 viewProjectionMatrix;
	mat4 invViewMatrix;
	mat4 invProjectionMatrix;
	mat4 invViewProjectionMatrix;
	mat4 prevViewMatrix;
	mat4 prevProjectionMatrix;
	mat4 prevViewProjectionMatrix;
	mat4 prevInvViewMatrix;
	mat4 prevInvProjectionMatrix;
	mat4 prevInvViewProjectionMatrix;
	vec4 cameraPosition;
	vec4 cameraDirection;
	uint frame;
} uPerFrameData;

layout(push_constant) uniform PushConsts 
{
	uint directionalLightCount;
} uPushConsts;

struct ShadowData
{
	mat4 shadowViewProjectionMatrix;
	vec4 shadowCoordScaleBias;
};

struct DirectionalLight
{
	vec4 color;
	vec4 direction;
	uint shadowDataOffset;
	uint shadowDataCount;
};

struct PointLight
{
	vec4 positionRadius;
	vec4 colorInvSqrAttRadius;
	//uint shadowDataOffset;
	//uint shadowDataCount;
};

struct SpotLight
{
	vec4 colorInvSqrAttRadius;
	vec4 positionAngleScale;
	vec4 directionAngleOffset;
	vec4 boundingSphere;
	//uint shadowDataOffset;
	//uint shadowDataCount;
};


layout(set = 2, binding = 0) readonly buffer DirectionalLights 
{
	DirectionalLight lights[];
} uDirectionalLights;

layout(set = 2, binding = 1) readonly buffer PointLights 
{
	PointLight lights[];
} uPointLights;

layout(set = 2, binding = 2) readonly buffer SpotLights 
{
	SpotLight lights[];
} uSpotLights;

layout(set = 2, binding = 3) readonly buffer Shadows 
{
	ShadowData data[];
} uShadowData;

layout(set = 2, binding = 4) readonly buffer ZBins 
{
	uvec2 bins[];
} uZBins;

layout(set = 2, binding = 5) uniform sampler2DShadow uShadowTexture;

layout(set = 3, binding = 0) buffer PointLightBitMask 
{
	uint mask[];
} uPointLightBitMask;

layout(set = 3, binding = 1) buffer SpotLightBitMask 
{
	uint mask[];
} uSpotLightBitMask;

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a2 = roughness*roughness;
    a2 *= a2;
    float NdotH2 = max(dot(N, H), 0.0);
    NdotH2 *= NdotH2;

    float nom   = a2;
    float denom = NdotH2 * (a2 - 1.0) + 1.0;

    denom = PI * denom * denom;

    return nom / max(denom, 0.0000001);
}

float GeometrySmith(float NdotV, float NdotL, float roughness)
{
	float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float ggx2 =  NdotV / max(NdotV * (1.0 - k) + k, 0.0000001);
    float ggx1 = NdotL / max(NdotL * (1.0 - k) + k, 0.0000001);

    return ggx1 * ggx2;
}


vec3 fresnelSchlick(float HdotV, vec3 F0)
{
	float power = (-5.55473 * HdotV - 6.98316) * HdotV;
	return F0 + (1.0 - F0) * pow(2.0, power);
}

float interleavedGradientNoise(vec2 v)
{
	vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
	return fract(magic.z * dot(v, magic.xy));
}

float smoothDistanceAtt(float squaredDistance, float invSqrAttRadius)
{
	float factor = squaredDistance * invSqrAttRadius;
	float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);
	return smoothFactor * smoothFactor;
}

float getDistanceAtt(vec3 unnormalizedLightVector, float invSqrAttRadius)
{
	float sqrDist = dot(unnormalizedLightVector, unnormalizedLightVector);
	float attenuation = 1.0 / (max(sqrDist, invSqrAttRadius));
	attenuation *= smoothDistanceAtt(sqrDist, invSqrAttRadius);
	
	return attenuation;
}

vec3 evaluatePointLight(
	inout mat3 viewMatrix,
	inout vec3 albedo, 
	inout vec3 N, 
	inout vec3 F0, 
	inout vec3 V,
	inout vec3 viewSpacePosition,
	inout float NdotV,
	inout float metallic, 
	inout float roughness,
	uint index)
{
	vec4 positionRadius = uPointLights.lights[index].positionRadius;
	vec3 unnormalizedLightVector = positionRadius.xyz - viewSpacePosition;
	vec3 L = normalize(unnormalizedLightVector);
	float att = getDistanceAtt(unnormalizedLightVector, uPointLights.lights[index].colorInvSqrAttRadius.w);

	vec3 H = normalize(V + L);
	float NdotL = max(dot(N, L), 0.0);

	// Cook-Torrance BRDF
	float NDF = DistributionGGX(N, H, roughness);
	float G = GeometrySmith(NdotV, NdotL, roughness);
	vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);

	vec3 numerator = NDF * G * F;
	float denominator = max(4 * NdotV * NdotL, 0.0000001);

	vec3 specular = numerator / denominator;

	// because of energy conversion kD and kS must add up to 1.0
	vec3 kD = vec3(1.0) - F;
	// multiply kD by the inverse metalness so if a material is metallic, it has no diffuse lighting (and otherwise a blend)
	kD *= 1.0 - metallic;

	vec3 radiance = uPointLights.lights[index].colorInvSqrAttRadius.rgb * att;
	return (kD * albedo * (1.0 / PI) + specular) * radiance * NdotL;
}

vec3 evaluateDirectionalLight(
	inout mat3 viewMatrix,
	inout vec3 albedo, 
	inout vec3 N, 
	inout vec3 F0, 
	inout vec3 V,
	inout vec3 viewSpacePosition,
	inout float NdotV,
	inout float metallic, 
	inout float roughness,
	uint index)
{
	vec3 L = viewMatrix * uDirectionalLights.lights[index].direction.xyz;
	vec3 H = normalize(V + L);
    
	float NdotL = max(dot(N, L), 0.0);
	
	float NDF = DistributionGGX(N, H, roughness);
	float G = GeometrySmith(NdotV, NdotL, roughness);
	vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    
	vec3 numerator = NDF * G * F;
	float denominator = max(4 * NdotV * NdotL, 0.0000001);
    
	vec3 specular = numerator / denominator;
    
	// because of energy conversion kD and kS must add up to 1.0
	vec3 kD = vec3(1.0) - F;
	// multiply kD by the inverse metalness so if a material is metallic, it has no diffuse lighting (and otherwise a blend)
	kD *= 1.0 - metallic;
    
	vec3 result = (kD * albedo * (1.0 / PI) + specular) * NdotL * uDirectionalLights.lights[index].color.rgb;
	
	uint shadowDataCount = uDirectionalLights.lights[index].shadowDataCount;
	if(shadowDataCount > 0)
	{		
		uint shadowDataOffset = uDirectionalLights.lights[index].shadowDataOffset;
		vec3 shadowCoord = vec3(2.0);
		vec2 invShadowTextureSize = 1.0 / textureSize(uShadowTexture, 0).xy;
		vec4 offsetPos = uPerFrameData.invViewMatrix * vec4(0.1 * L + viewSpacePosition, 1.0);

		uint split = 0;
		for (; split < shadowDataCount; ++split)
		{
			const vec4 projCoords4 = 
			uShadowData.data[shadowDataOffset + split].shadowViewProjectionMatrix * offsetPos;
			shadowCoord = (projCoords4.xyz / projCoords4.w);
			shadowCoord.xy = shadowCoord.xy * 0.5 + 0.5; 
			
			// test if projected coordinate is inside texture
			// add small guard band at edges to avoid PCF sampling outside texture
			if(all(greaterThanEqual(shadowCoord.xy, vec2(0.003))) && all(lessThan(shadowCoord.xy, vec2(1.0 - 0.003))))
			{
				vec4 scaleBias = uShadowData.data[shadowDataOffset + split].shadowCoordScaleBias;
				shadowCoord.xy = shadowCoord.xy * scaleBias.xy + scaleBias.zw;
				break;
			}
		}

		
		float shadow = 0.0;
		
		const float noise = interleavedGradientNoise(vec2(gl_GlobalInvocationID.xy));// * 0.5 + (uOddFrame ? 0.5 : 0.0);

		const float rotSin = sin(2.0 * PI * noise);
		const float rotCos = cos(2.0 * PI * noise);

		const mat2 rotation = mat2(rotCos, rotSin, -rotSin, rotCos);

		const vec2 samples[8] = 
		{ 
			vec2(-0.7071, 0.7071),
			vec2(0.0, -0.8750),
			vec2(0.5303, 0.5303),
			vec2(-0.625, 0.0),
			vec2(0.3536, -0.3536),
			vec2(0.0, 0.375),
			vec2(-0.1768, -0.1768),
			vec2(0.125, 0.0)
		};

		const float splitMult = split == 0 ? 5.0 : split == 1 ? 2.0 : 1.0;

		for(int i = 0; i < 8; ++i)
		{
			vec2 offset = rotation * samples[i];
			shadow += texture(uShadowTexture, vec3(shadowCoord.xy + offset * invShadowTextureSize * splitMult, shadowCoord.z)).x;
		}
		shadow *= 1.0 / 8.0;
		
		result *= (1.0 - shadow);
	}
	return result;
}

vec3 accurateLinearToSRGB(in vec3 linearCol)
{
	vec3 sRGBLo = linearCol * 12.92;
	vec3 sRGBHi = (pow(abs(linearCol), vec3(1.0/2.4)) * 1.055) - 0.055;
	vec3 sRGB = mix(sRGBLo, sRGBHi, vec3(greaterThan(linearCol, vec3(0.0031308))));
	return sRGB;
}

vec3 accurateSRGBToLinear(in vec3 sRGBCol)
{
	vec3 linearRGBLo = sRGBCol * (1.0 / 12.92);
	vec3 linearRGBHi = pow((sRGBCol + vec3(0.055)) * vec3(1.0 / 1.055), vec3(2.4));
	vec3 linearRGB = mix(linearRGBLo, linearRGBHi, vec3(greaterThan(sRGBCol, vec3(0.04045))));
	return linearRGB;
}

uint getTileAddress()
{
	uvec2 tile = uvec2(gl_GlobalInvocationID.xy) / TILE_SIZE;
	uint domainSizeX = uint(textureSize(uTextures[0], 0).x);
	return tile.x + tile.y * (domainSizeX / TILE_SIZE + ((domainSizeX % TILE_SIZE == 0) ? 0 : 1));
}

const vec3 kRadarColors[14] = 
{
    {0,0.9255,0.9255},   // cyan
    {0,0.62745,0.9647},  // light blue
    {0,0,0.9647},        // blue
    {0,1,0},             // bright green
    {0,0.7843,0},        // green
    {0,0.5647,0},        // dark green
    {1,1,0},             // yellow
    {0.90588,0.75294,0}, // yellow-orange
    {1,0.5647,0},        // orange
    {1,0,0},             // bright red
    {0.8392,0,0},        // red
    {0.75294,0,0},       // dark red
    {1,0,1},             // magenta
    {0.6,0.3333,0.7882}, // purple
};

vec3 convertNumberOfLightsToRadarColor(uint nNumLightsInThisTile, uint uMaxNumLightsPerTile)
{
    // black for no lights
    if( nNumLightsInThisTile == 0 ) return vec3(0.0);
    // light purple for reaching the max
    else if( nNumLightsInThisTile == uMaxNumLightsPerTile ) return vec3(0.847,0.745,0.921);
    // white for going over the max
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return vec3(1.0);
    // else use weather radar colors
    else
    {
        // use a log scale to provide more detail when the number of lights is smaller

        // want to find the base b such that the logb of uMaxNumLightsPerTile is 14
        // (because we have 14 radar colors)
        float fLogBase = exp2(0.07142857f*log2(float(uMaxNumLightsPerTile)));

        // change of base
        // logb(x) = log2(x) / log2(b)
        uint nColorIndex = uint(floor(log2(float(nNumLightsInThisTile)) / log2(fLogBase)));
        return kRadarColors[nColorIndex];
    }
}

void main() 
{
	float depth = texelFetch(uTextures[DEPTH_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).x;
	
	if (depth == 1.0)
	{
		imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(0.529, 0.808, 0.922), 1.0));
		return;
	}
	
	vec2 domainSize = textureSize(uTextures[0], 0).xy;
	vec2 texelSize = vec2(1.0 / domainSize);
	vec2 texCoord = vec2(vec2(gl_GlobalInvocationID.xy) + 0.5) * texelSize;
	const vec4 clipSpacePosition = vec4(vec2(texCoord) * 2.0 - 1.0, depth, 1.0);
	vec4 viewSpacePosition = uPerFrameData.invProjectionMatrix * clipSpacePosition;
	viewSpacePosition /= viewSpacePosition.w;
	
	mat3 viewMatrix = mat3(uPerFrameData.viewMatrix);
	vec3 albedo = accurateSRGBToLinear(texelFetch(uTextures[ALBEDO_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).rgb);
	vec3 N = texelFetch(uTextures[NORMAL_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).xyz;
	float metallic = texelFetch(uTextures[MRO_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).x;
	vec3 F0 = mix(vec3(0.04), albedo, metallic);
	vec3 V = -normalize(viewSpacePosition.xyz);
	float NdotV = max(dot(N, V), 0.0);
	float roughness = texelFetch(uTextures[MRO_TEXTURE_INDEX], ivec2(gl_GlobalInvocationID.xy), 0).y;
	
	vec3 result = vec3(0.0);
	
	for (uint i = 0; i < uPushConsts.directionalLightCount; ++i)
	{
		result += evaluateDirectionalLight(viewMatrix, albedo, N, F0, V, viewSpacePosition.xyz, NdotV, metallic, roughness, i);
	}
	result += 0.1 * albedo;
	
	uint wordMin = 0;
	uint wordMax = MAX_POINT_LIGHT_WORDS - 1;
	
	uint address = getTileAddress() * MAX_POINT_LIGHT_WORDS;
	uint zBinAddress = clamp(uint(floor(-viewSpacePosition.z)), 0, 8191);
	uint zBinData = uZBins.bins[zBinAddress].x;
	uint minIndex = (zBinData & 0xFFFF0000) >> 16;
	uint maxIndex = zBinData & 0xFFFF;
	wordMin = minIndex / 32;
	wordMax = maxIndex / 32;
	
	uint count = 0;
	for (uint wordIndex = wordMin; wordIndex <= wordMax; ++wordIndex)
	{
		uint mask = uPointLightBitMask.mask[address + wordIndex];
		
		while (mask != 0)
		{
			uint bitIndex = findLSB(mask);
			uint index = 32 * wordIndex + bitIndex;
			mask ^= (1 << bitIndex);
			if (index >= minIndex && index <= maxIndex)
			{
				result += evaluatePointLight(viewMatrix, albedo, N, F0, V, viewSpacePosition.xyz, NdotV, metallic, roughness, index);
			}
			++count;
		}
	}
	
	result = accurateLinearToSRGB(result);
	//result = mix(convertNumberOfLightsToRadarColor(count, 144), result, 0.5);
	imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1.0));
}