#version 450

#include "rayTraceTest_bindings.h"

struct InternalNode
{
	float aabb[6];
	uint leftChild;
	uint rightChild;
};

struct LeafNode
{
	float vertices[9];
};

layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING) uniform writeonly image2D uResultImage;

layout(set = INTERNAL_NODES_SET, binding = INTERNAL_NODES_BINDING) readonly buffer INTERNAL_NODES
{
	InternalNode uInternalNodes[];
};

layout(set = LEAF_NODES_SET, binding = LEAF_NODES_BINDING) readonly buffer LEAF_NODES
{
	LeafNode uLeafNodes[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(constant_id = WIDTH_CONST_ID) const uint cWidth = 1600;
layout(constant_id = HEIGHT_CONST_ID) const uint cHeight = 900;
layout(constant_id = TEXEL_WIDTH_CONST_ID) const float cTexelWidth = 1.0 / 1600.0;
layout(constant_id = TEXEL_HEIGHT_CONST_ID) const float cTexelHeight = 1.0 / 900;

bool isLeafNode(uint node)
{
	return node >= (1u << 31);
}

bool intersectAABB(const vec3 invDir, const vec3 originDivDir, const vec3 aabbMin, const vec3 aabbMax, out float tNear) 
{
	const vec3 tMin = aabbMin * invDir - originDivDir;
	const vec3 tMax = aabbMax * invDir - originDivDir;
	const vec3 t1 = min(tMin, tMax);
	const vec3 t2 = max(tMin, tMax);
	tNear = max(max(t1.x, t1.y), max(t1.z, 0.0));
	const float tFar = min(min(t2.x, t2.y), t2.z);
	return tNear <= tFar;
}

bool intersectTriangle(const vec3 rayOrigin, const vec3 rayDir, const vec3 v0, const vec3 v1, const vec3 v2, out vec3 uvt)
{
	const vec3 e0 = v1 - v0;
    const vec3 e1 = v2 - v0;
    const vec3 s0 = cross(rayDir, e1);
    const float  invd = 1.0 / (dot(s0, e0));
    const vec3 d = rayOrigin - v0;
    const float  b0 = dot(d, s0) * invd;
    const vec3 s1 = cross(d, e0);
    const float  b1 = dot(rayDir, s1) * invd;
    const float temp = dot(e1, s1) * invd;
    
	uvt = vec3(b0, b1, temp);
	return !(b0 < 0.0 || b0 > 1.0 || b1 < 0.0 || b0 + b1 > 1.0 || temp < 0.0/* || temp > isect.uvwt.w*/);
}

void main() 
{
	if (gl_GlobalInvocationID.x >= cWidth || gl_GlobalInvocationID.y >= cHeight)
	{
		return;
	}
	
	vec4 rayOriginSS = vec4((vec2(gl_GlobalInvocationID.xy) + 0.5) * vec2(cTexelWidth, cTexelHeight) * 2.0 - 1.0, 1.0, 1.0);
	vec4 rayEndSS = vec4(rayOriginSS.xy, 0.9, 1.0);
	rayOriginSS = uPushConsts.invViewProjection * rayOriginSS;
	rayEndSS = uPushConsts.invViewProjection * rayEndSS;
	
	vec3 rayOrigin = rayOriginSS.xyz / rayOriginSS.w;
	vec3 rayDir = normalize(rayEndSS.xyz / rayEndSS.w - rayOrigin);
	vec3 invRayDir;
	invRayDir[0] = 1.0 / (rayDir[0]  != 0.0 ? rayDir[0] : pow(2.0, -80.0));
	invRayDir[1] = 1.0 / (rayDir[1]  != 0.0 ? rayDir[1] : pow(2.0, -80.0));
	invRayDir[2] = 1.0 / (rayDir[2]  != 0.0 ? rayDir[2] : pow(2.0, -80.0));
	vec3 originDivDir = rayOrigin * invRayDir;
	
	uint stack[32];
	uint stackPtr = 0;
	stack[stackPtr++] = -1;
	
	uint curNodeIdx = 0;
	uint triangleIdx = -1;
	vec3 barycentrics = vec3(-1.0);
	uint iterations = 0;
	
	//for (uint i = 0; i < uLeafNodes.length(); ++i)
	//{
	//	LeafNode triangle = uLeafNodes[i];
	//	if (intersectTriangle(rayOrigin, rayDir, vec3(triangle.vertices[0], triangle.vertices[1], triangle.vertices[2]), 
	//		vec3(triangle.vertices[3], triangle.vertices[4], triangle.vertices[5]), 
	//		vec3(triangle.vertices[6], triangle.vertices[7], triangle.vertices[8]), barycentrics))
	//	{
	//		triangleIdx = i;
	//		break;
	//	}
	//}
	
	float closestDistance = 9999999999999999.0;
	
	while (curNodeIdx != -1)
	{
		++iterations;
		InternalNode node = uInternalNodes[curNodeIdx];
		if (isLeafNode(node.leftChild))
		{
			LeafNode triangle = uLeafNodes[node.leftChild - (1u << 31)];
			if (intersectTriangle(rayOrigin, rayDir, vec3(triangle.vertices[0], triangle.vertices[1], triangle.vertices[2]), 
									vec3(triangle.vertices[3], triangle.vertices[4], triangle.vertices[5]), 
									vec3(triangle.vertices[6], triangle.vertices[7], triangle.vertices[8]), barycentrics))
			{
				if (barycentrics.z < closestDistance)
				{
					closestDistance = barycentrics.z;
					triangleIdx = node.leftChild - (1u << 31);
				}
			}
			curNodeIdx = stack[--stackPtr]; // pop
		}
		else
		{
			InternalNode leftChild = uInternalNodes[node.leftChild];
			float leftTMin = 0.0;
			bool hitLeft = intersectAABB(invRayDir, originDivDir, vec3(leftChild.aabb[0], leftChild.aabb[1], leftChild.aabb[2]), vec3(leftChild.aabb[3], leftChild.aabb[4], leftChild.aabb[5]), leftTMin);
			
			InternalNode rightChild = uInternalNodes[node.rightChild];
			float rightTMin = 0.0;
			bool hitRight = intersectAABB(invRayDir, originDivDir, vec3(rightChild.aabb[0], rightChild.aabb[1], rightChild.aabb[2]), vec3(rightChild.aabb[3], rightChild.aabb[4], rightChild.aabb[5]), rightTMin);
			
			if (!hitLeft && !hitRight)
			{
				curNodeIdx = stack[--stackPtr]; // pop
			}
			else
			{
				curNodeIdx = hitLeft ? node.leftChild : node.rightChild;
				if (hitLeft && hitRight)
				{
					stack[stackPtr++] = node.rightChild; // push
				}
			}
		}
	}
	
	vec3 result = vec3(0.529, 0.808, 0.922);
	if (triangleIdx != -1)
	{
		LeafNode triangle = uLeafNodes[triangleIdx];
		vec3 v0 = vec3(triangle.vertices[0], triangle.vertices[1], triangle.vertices[2]);
		vec3 v1 = vec3(triangle.vertices[3], triangle.vertices[4], triangle.vertices[5]);
		vec3 v2 = vec3(triangle.vertices[6], triangle.vertices[7], triangle.vertices[8]);
		vec3 N = cross(normalize(v1 - v0), normalize(v2 - v0));
		float NdotV = dot(rayDir, N);
		N = NdotV < 0.0 ? -N : N;
		NdotV = dot(rayDir, N);
		result = vec3(NdotV);
	}
	result = vec3(iterations / 500000.0);
	
	imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1.0));
}