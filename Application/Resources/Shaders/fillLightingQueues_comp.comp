#version 450

#include "fillLightingQueues_bindings.h"

struct VkDispatchIndirectCommand 
{
	uint x;
	uint y;
	uint z;
};

layout(set = AGE_IMAGE_SET, binding = AGE_IMAGE_BINDING, r8) uniform image3D uAgeImage;

layout(set = QUEUE_BUFFER_SET, binding = QUEUE_BUFFER_BINDING) buffer QUEUE_BUFFER
{
	uint uQueueSize;
	float uP;
	uint uQueue[];
};

layout(set = INDIRECT_CMD_SET, binding = INDIRECT_CMD_BINDING) buffer INDIRECT_CMD_BUFFER
{
	VkDispatchIndirectCommand uCmd;
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout(constant_id = GRID_WIDTH_CONST_ID) const uint cGridWidth = 64;
layout(constant_id = GRID_HEIGHT_CONST_ID) const uint cGridHeight = 32;
layout(constant_id = GRID_DEPTH_CONST_ID) const uint cGridDepth = 64;
layout(constant_id = CASCADES_CONST_ID) const uint cCascades = 3;
layout(constant_id = GRID_BASE_SCALE_CONST_ID) const float cGridBaseScale = 2.0;
layout(constant_id = QUEUE_CAPACITY_CONST_ID) const uint cQueueCapacity = 4096;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uint rngState = 0;

uint rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rngState ^= (rngState << 13);
    rngState ^= (rngState >> 17);
    rngState ^= (rngState << 5);
    return rngState;
}

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

void main() 
{
	const ivec3 gridSize = ivec3(cGridWidth, cGridHeight, cGridDepth);
	
	// early exit if this invocation is outside the grid
	if (gl_GlobalInvocationID.x < gridSize.x && gl_GlobalInvocationID.y < gridSize.y && gl_GlobalInvocationID.z < gridSize.z)
	{
		uint idx = gl_GlobalInvocationID.x + (gl_GlobalInvocationID.y * cGridWidth * cGridDepth) + (gl_GlobalInvocationID.z * cGridWidth);
		rngState = wang_hash(idx * floatBitsToInt(uPushConsts.time));
		
		const float p = uP;
		float curGridScale = cGridBaseScale;
		
		// iterate over all cascades
		for (int i = 0; i < cCascades; ++i)
		{
			const float rnd = rand_xorshift() * (1.0 / 4294967296.0);
			
			const ivec3 cameraCoord = ivec3(round(uPushConsts.cameraPos.xyz * curGridScale));
			ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
			
			// move coordinate to world space fixed coordinate system (toroidal addressing)
			coord += cameraCoord - (gridSize / 2);
			// apply wrapping
			coord = ivec3(fract(coord / vec3(gridSize)) * gridSize);
			// cascades are stacked on top of each other in order to combine them in a single image
			coord += ivec3(0, i * cGridHeight, 0);
			// actually cascades are stacked along the z axis, so swizzle z and y
			coord = coord.xzy;
				
			const float age = imageLoad(uAgeImage, coord).x;
			bool enqueued = false;
			
			if (age * rnd > p || age == 0.0)
			{
				uint queueIndex = atomicAdd(uQueueSize, 1);
				if (queueIndex < cQueueCapacity)
				{
					atomicAdd(uCmd.x, 1);
					uQueue[queueIndex] = idx;
					enqueued = true;
				}
			}
			
			if (age != 0.0 && !enqueued)
			{
				imageStore(uAgeImage, coord, vec4(age + 1.0 / 256.0));
			}
			
			idx += cGridWidth * cGridHeight * cGridDepth;
			curGridScale *= 0.5;
		}
	}
}