#version 450

#include "fillLightingQueues_bindings.h"

struct VkDispatchIndirectCommand 
{
	uint x;
	uint y;
	uint z;
};

layout(set = AGE_IMAGE_SET, binding = AGE_IMAGE_BINDING, r8) uniform image3D uAgeImage;
layout(set = HIZ_IMAGE_SET, binding = HIZ_IMAGE_BINDING) uniform sampler2D uHizImage;

layout(set = QUEUE_BUFFER_SET, binding = QUEUE_BUFFER_BINDING) buffer QUEUE_BUFFER
{
	uint uQueueSize;
	float uP;
	uint uQueue[];
};

layout(set = CULLED_BUFFER_SET, binding = CULLED_BUFFER_BINDING) buffer CULLED_BUFFER
{
	uint uCulled;
};

layout(set = INDIRECT_CMD_SET, binding = INDIRECT_CMD_BINDING) buffer INDIRECT_CMD_BUFFER
{
	VkDispatchIndirectCommand uCmd;
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout(constant_id = GRID_WIDTH_CONST_ID) const uint cGridWidth = 64;
layout(constant_id = GRID_HEIGHT_CONST_ID) const uint cGridHeight = 32;
layout(constant_id = GRID_DEPTH_CONST_ID) const uint cGridDepth = 64;
layout(constant_id = CASCADES_CONST_ID) const uint cCascades = 3;
layout(constant_id = GRID_BASE_SCALE_CONST_ID) const float cGridBaseScale = 2.0;
layout(constant_id = QUEUE_CAPACITY_CONST_ID) const uint cQueueCapacity = 4096;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uint rngState = 0;

uint rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rngState ^= (rngState << 13);
    rngState ^= (rngState >> 17);
    rngState ^= (rngState << 5);
    return rngState;
}

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

void main() 
{
	const ivec3 gridSize = ivec3(cGridWidth, cGridHeight, cGridDepth);
	
	// early exit if this invocation is outside the grid
	if (gl_GlobalInvocationID.x < gridSize.x && gl_GlobalInvocationID.y < gridSize.y && gl_GlobalInvocationID.z < gridSize.z)
	{
		uint idx = gl_GlobalInvocationID.x + (gl_GlobalInvocationID.y * cGridWidth * cGridDepth) + (gl_GlobalInvocationID.z * cGridWidth);
		rngState = wang_hash(idx * floatBitsToInt(uPushConsts.time));
		
		const float p = uP;
		float curGridScale = cGridBaseScale;
		
		// iterate over all cascades
		for (int i = 0; i < cCascades; ++i)
		{
			const float rnd = rand_xorshift() * (1.0 / 4294967296.0);
			
			const ivec3 cameraCoord = ivec3(round(uPushConsts.cameraPos.xyz * curGridScale));
			ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
			
			// move coordinate to world space fixed coordinate system (toroidal addressing)
			coord += cameraCoord - (gridSize / 2);
			
			// frustum culling
			bool outsideFrustum = false;
			{
				vec4 sBox = vec4(vec2(9999.0), vec2(-9999.0));
				float maxDepth = -9999.0;
				float minDepth = 9999.0;
				ivec3 outCount[2];
				outCount[0] = ivec3(0);
				outCount[1] = ivec3(0);
				for (uint j = 0; j < 8; ++j)
				{
					vec4 position = vec4(((j & 0x4) == 0) ? -1.0 : 1.0,
										((j & 0x2) == 0) ? -1.0 : 1.0,
										((j & 0x1) == 0) ? -1.0 : 1.0,
										1.0);
					position.xyz += coord;
					position.xyz *= 1.0 / curGridScale;
					position = uPushConsts.viewProjectionMatrix * position;
					const bool behindNearPlane = (abs(position.z) > position.w) || (position.z < 0.0);
					position.xyz /= position.w;
					
					outCount[0][0] += position.x < -1 ? 1 : 0;
					outCount[0][1] += position.y < -1 ? 1 : 0; 
					outCount[0][2] += behindNearPlane ? 1 : 0; 
					outCount[1][0] += position.x > 1 ? 1 : 0;
					outCount[1][1] += position.y > 1 ? 1 : 0; 
					
					position.xy = position.xy * 0.5 + 0.5;
					sBox.xy = min(sBox.xy, position.xy);
					sBox.zw = max(sBox.zw, position.xy);
					maxDepth = max(maxDepth, behindNearPlane ? 1.0 : position.z);
					minDepth = min(minDepth, behindNearPlane ? 1.0 : position.z);
				}
				
				outCount[0] = max(outCount[0], outCount[1]);
				outsideFrustum = max(max(outCount[0].x, outCount[0].x), outCount[0].z) == 8;
				
				if (!outsideFrustum)
				{
					vec2 size = ceil(vec2(sBox.zw - sBox.xy) * uPushConsts.resolution);
					float level = clamp(ceil(log2(max(size.x, size.y) * 0.5)), 0.0, 11.0);
					vec4 samples;
					samples[0] = textureLod(uHizImage, clamp(vec2(sBox.xy), 0.0.xx, 1.0.xx), level).x;
					samples[1] = textureLod(uHizImage, clamp(vec2(sBox.zy), 0.0.xx, 1.0.xx), level).x;
					samples[2] = textureLod(uHizImage, clamp(vec2(sBox.xw), 0.0.xx, 1.0.xx), level).x;
					samples[3] = textureLod(uHizImage, clamp(vec2(sBox.zw), 0.0.xx, 1.0.xx), level).x;
					float hiZDepthMin = min(min(samples.x, samples.y), min(samples.z, samples.w));
					float hiZDepthMax = max(max(samples.x, samples.y), max(samples.z, samples.w));
					
					bool visible = maxDepth >= hiZDepthMin;
					bool partiallyOccluded = visible && minDepth <= hiZDepthMax;
					outsideFrustum = !visible;//outsideFrustum || !partiallyOccluded;
				}
				
				
				if (outsideFrustum)
				{
					atomicAdd(uCulled, 1);
				}
			}
				
			// apply wrapping
			coord = ivec3(fract(coord / vec3(gridSize)) * gridSize);
			// cascades are stacked on top of each other in order to combine them in a single image
			coord += ivec3(0, i * cGridHeight, 0);
			// actually cascades are stacked along the z axis, so swizzle z and y
			coord = coord.xzy;
				
			const float age = imageLoad(uAgeImage, coord).x;
			bool enqueued = false;
			
			if ((rnd > p || age == 0.0) && !outsideFrustum)
			{
				uint queueIndex = atomicAdd(uQueueSize, 1);
				if (queueIndex < cQueueCapacity)
				{
					atomicAdd(uCmd.x, 1);
					uQueue[queueIndex] = idx;
					enqueued = true;
				}
			}
			
			if (age != 0.0 && !enqueued)
			{
				imageStore(uAgeImage, coord, vec4(age + 1.0 / 256.0));
			}
			
			idx += cGridWidth * cGridHeight * cGridDepth;
			curGridScale *= 0.5;
		}
	}
}