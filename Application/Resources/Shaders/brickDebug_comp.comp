#version 450

#include "brickDebug_bindings.h"

layout(constant_id = BRICK_VOLUME_WIDTH_CONST_ID) const uint cBrickVolumeWidth = 128;
layout(constant_id = BRICK_VOLUME_HEIGHT_CONST_ID) const uint cBrickVolumeHeight = 64;
layout(constant_id = BRICK_VOLUME_DEPTH_CONST_ID) const uint cBrickVolumeDepth = 128;
layout(constant_id = VOXEL_GRID_WIDTH_CONST_ID) const uint cVoxelGridWidth = 2048;
layout(constant_id = VOXEL_GRID_HEIGHT_CONST_ID) const uint cVoxelGridHeight = 1024;
layout(constant_id = VOXEL_GRID_DEPTH_CONST_ID) const uint cVoxelGridDepth = 2048;
layout(constant_id = VOXEL_SCALE_CONST_ID) const float cVoxelScale = 16.0;
layout(constant_id = BIN_VIS_BRICK_SIZE_CONST_ID) const uint cBinVisBrickSize = 16;
layout(constant_id = COLOR_BRICK_SIZE_CONST_ID) const uint cColorBrickSize = 4;
layout(constant_id = WIDTH_CONST_ID) const uint cWidth = 1600;
layout(constant_id = HEIGHT_CONST_ID) const uint cHeight = 900;
layout(constant_id = TEXEL_WIDTH_CONST_ID) const float cTexelWidth = 1.0 / 1600.0;
layout(constant_id = TEXEL_HEIGHT_CONST_ID) const float cTexelHeight = 1.0 / 900;

layout(set = BRICK_PTR_IMAGE_SET, binding = BRICK_PTR_IMAGE_BINDING) uniform usampler3D uBrickPtrImage;
layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING, rgba16f) uniform writeonly image2D uResultImage;
layout(set = BIN_VIS_IMAGE_SET, binding = BIN_VIS_IMAGE_BINDING) uniform usampler3D uBinVisImage;
layout(set = COLOR_IMAGE_SET, binding = COLOR_IMAGE_BINDING) uniform sampler3D uColorImage;

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

bool raymarch(const vec3 origin, const vec3 dir, out vec3 color)
{
	const vec3 p0 = origin * cVoxelScale;
	float t = 0.0;
	const vec3 gridSize = vec3(cVoxelGridWidth, cVoxelGridHeight, cVoxelGridDepth);
	
	while (true)
	{
		vec3 gridCoord = p0 + t * dir;
		if (any(lessThan(gridCoord, uPushConsts.gridOffset)) || any(greaterThanEqual(gridCoord, gridSize + uPushConsts.gridOffset)))
		{
			return false;
		}
		
		const vec3 brickGridSize = vec3(cBrickVolumeWidth, cBrickVolumeHeight, cBrickVolumeDepth);
		const vec3 invBrickGridSize = 1.0 / brickGridSize;
		
		const ivec3 brickCoord = ivec3(fract(floor(gridCoord / float(cBinVisBrickSize)) * invBrickGridSize) * brickGridSize);
		const uint brickPtr = texelFetch(uBrickPtrImage, brickCoord, 0).x;
		
		// skip brick
		if (brickPtr == 0)
		{
			const vec3 invDir = 1.0 / dir;
			const vec3 originDivDir = p0 * invDir;
			const vec3 aabbMin = floor(gridCoord / float(cBinVisBrickSize)) * cBinVisBrickSize;
			const vec3 aabbMax = aabbMin + cBinVisBrickSize;
			const vec3 tMin = aabbMin * invDir - originDivDir;
			const vec3 tMax = aabbMax * invDir - originDivDir;
			const vec3 t2 = max(tMin, tMax);
			t = max(min(min(t2.x, t2.y), t2.z), t) + 0.1;
			continue;
		}
		
		uvec2 binVis = uvec2(0);
		if (brickPtr != 0)
		{
			const ivec3 brickAddress = ivec3((brickPtr >> 16) & 0xFF, (brickPtr >> 8) & 0xFF, (brickPtr) & 0xFF);
			
			const float cubesPerBrick = cBinVisBrickSize * 0.25;
			const int cubesPerBrickI = int(cBinVisBrickSize) / 4;
			const ivec3 cubeCoord = ivec3(fract(gridCoord / float(cBinVisBrickSize)) * cubesPerBrick);
			
			const ivec3 cubeAddress = brickAddress * cubesPerBrickI + cubeCoord;
			
			binVis[0] = texelFetch(uBinVisImage, ivec3(cubeAddress.x, cubeAddress.y * 2 + 0, cubeAddress.z), 0).x;
			binVis[1] = texelFetch(uBinVisImage, ivec3(cubeAddress.x, cubeAddress.y * 2 + 1, cubeAddress.z), 0).x;
		}
		
		bool hit = false;
		
		// dda inside 4x4x4 cube
		if (binVis.x != 0 || binVis.y != 0)
		{
			// grid space
			const vec3 gridStep = sign(dir);
			const vec3 corner = max(gridStep, vec3(0.0));
			
			// ray space
			const vec3 inv = 1.0 / dir;
			vec3 ratio = (floor(gridCoord) + corner - gridCoord) * inv;
			const vec3 ratioStep = gridStep * inv;
			const vec3 cubeCoord = floor(gridCoord * 0.25) * 4.0;
			gridCoord = floor(gridCoord);
			
			while (true)
			{
				ivec3 bitCoord = ivec3(fract(gridCoord * 0.25) * 4.0);
				uint bitIdx = bitCoord.x + bitCoord.z * 4 + bitCoord.y * 16;
				bool upper = bitIdx > 31;
				bitIdx = upper ? bitIdx - 32 : bitIdx;
				
				if((binVis[upper ? 1 : 0] & (1u << bitIdx)) != 0)
				{
					hit = true;
					break;
				}
				
				const ivec3 mask = ivec3(lessThanEqual(ratio.xyz, min(ratio.yzx, ratio.zxy)));
				gridCoord += gridStep * mask;		
				ratio += ratioStep * mask;
				
				if (cubeCoord != floor(gridCoord * 0.25) * 4.0)
				{
					break;
				}
			}
		}
		
		if (hit)
		{
			const ivec3 brickAddress = ivec3((brickPtr >> 16) & 0xFF, (brickPtr >> 8) & 0xFF, (brickPtr) & 0xFF);
			const ivec3 localCoord = ivec3(fract(gridCoord / float(cBinVisBrickSize)) * cColorBrickSize);
			const ivec3 colorAddress = brickAddress * int(cColorBrickSize) + localCoord;
			color = texelFetch(uColorImage, colorAddress, 0).rgb;
			return true;
		}
		
		// skip cube (the cube was empty or nothing got hit)
		{
			gridCoord = p0 + t * dir;
			const vec3 invDir = 1.0 / dir;
			const vec3 originDivDir = p0 * invDir;
			const vec3 aabbMin = floor(gridCoord * 0.25) * 4.0;
			const vec3 aabbMax = aabbMin + 4.0;
			const vec3 tMin = aabbMin * invDir - originDivDir;
			const vec3 tMax = aabbMax * invDir - originDivDir;
			const vec3 t2 = max(tMin, tMax);
			t = max(min(min(t2.x, t2.y), t2.z), t) + 0.1;
		}
	}
}

void main() 
{
	if (gl_GlobalInvocationID.x >= cWidth || gl_GlobalInvocationID.y >= cHeight)
	{
		return;
	}
	
	vec4 worldSpacePos = uPushConsts.invViewProjection * vec4(vec2(gl_GlobalInvocationID.xy) * vec2(cTexelWidth, cTexelHeight) * 2.0 - 1.0, 1.0, 1.0);
	worldSpacePos.xyz /= worldSpacePos.w;
	
	vec4 direction4 = uPushConsts.invViewProjection * vec4(vec2(gl_GlobalInvocationID.xy) * vec2(cTexelWidth, cTexelHeight) * 2.0 - 1.0, 0.0, 1.0);
	vec3 direction = normalize(direction4.xyz / direction4.w - worldSpacePos.xyz);

	vec3 color;
	if (raymarch(worldSpacePos.xyz, direction, color))
	{
		imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
	}
}