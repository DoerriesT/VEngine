#version 450

#include "clearBricks_bindings.h"

layout(set = BRICK_PTR_IMAGE_SET, binding = BRICK_PTR_IMAGE_BINDING, r32ui) uniform uimage3D uBrickPtrImage;
layout(set = BIN_VIS_IMAGE_BUFFER_SET, binding = BIN_VIS_IMAGE_BUFFER_BINDING, r32ui) uniform uimageBuffer uBinVisImageBuffer;
layout(set = COLOR_IMAGE_BUFFER_SET, binding = COLOR_IMAGE_BUFFER_BINDING, rgba16f) uniform imageBuffer uColorImageBuffer;

layout(set = FREE_BRICKS_BUFFER_SET, binding = FREE_BRICKS_BUFFER_BINDING) buffer FREE_BRICKS_BUFFER 
{
	int uNextFreeBrick;
    uint uFreeBricks[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout(constant_id = BRICK_VOLUME_WIDTH_CONST_ID) const uint cBrickVolumeWidth = 128;
layout(constant_id = BRICK_VOLUME_HEIGHT_CONST_ID) const uint cBrickVolumeHeight = 64;
layout(constant_id = BRICK_VOLUME_DEPTH_CONST_ID) const uint cBrickVolumeDepth = 128;
layout(constant_id = BIN_VIS_BRICK_SIZE_CONST_ID) const uint cBinVisBrickSize = 16;
layout(constant_id = COLOR_BRICK_SIZE_CONST_ID) const uint cColorBrickSize = 4;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() 
{
	const ivec3 gridSize = ivec3(cBrickVolumeWidth, cBrickVolumeHeight, cBrickVolumeDepth);
	
	// early exit if this invocation is outside the grid
	if (gl_GlobalInvocationID.x < gridSize.x && gl_GlobalInvocationID.y < gridSize.y && gl_GlobalInvocationID.z < gridSize.z)
	{		
		// is the voxel outside the grid after applying camera movement?
		ivec3 coord = ivec3(gl_GlobalInvocationID.xyz) + uPushConsts.diff;
		if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, gridSize)))
		{
			// move coordinate to world space fixed coordinate system (toroidal addressing)
			coord += uPushConsts.cameraCoord.xyz - (gridSize / 2) - uPushConsts.diff;
			// apply wrapping
			coord = ivec3(fract(coord / vec3(gridSize)) * gridSize);
			
			uint ptr = imageLoad(uBrickPtrImage, coord).x;
			if (ptr != 0)
			{
				--ptr;
				
				// clear brick
				const int binVisDataPerBrick = int(cBinVisBrickSize * cBinVisBrickSize * cBinVisBrickSize) / 32;
				for (int i = 0; i < binVisDataPerBrick; ++i)
				{
					imageStore(uBinVisImageBuffer, i + int(ptr) * binVisDataPerBrick, uvec4(0));
				}
				
				const int colorDataPerBrick = int(cColorBrickSize * cColorBrickSize * cColorBrickSize);
				for (int i = 0; i < colorDataPerBrick; ++i)
				{
					imageStore(uColorImageBuffer, i + int(ptr) * colorDataPerBrick, vec4(0.0));
				}
				
				uint offset = atomicAdd(uNextFreeBrick, -1) - 1;
				uFreeBricks[offset] = ptr;
				imageStore(uBrickPtrImage, coord, uvec4(0));
			}
		}
	}
}