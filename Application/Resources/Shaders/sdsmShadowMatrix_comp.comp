#version 450

#include "sdsmShadowMatrix_bindings.h"

#define PARTITIONS 4

layout(set = DEPTH_BOUNDS_SET, binding = DEPTH_BOUNDS_BINDING) buffer DEPTH_BOUNDS
{
    uint uMinDepth;
	uint uMaxDepth;
};

layout(set = SHADOW_DATA_SET, binding = SHADOW_DATA_BINDING) buffer SHADOW_DATA
{
    ShadowData uShadowData[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};


layout (local_size_x = PARTITIONS, local_size_y = 1, local_size_z = 1) in;

// partition index should be in range [0, PARTITIONS] inclusive
float logPartitionFromRange(uint split, float minZ, float maxZ)
{
	float range = maxZ - minZ;
	float ratio = maxZ / minZ;
    float p = (split + 1) / float(PARTITIONS);
	float log = minZ * pow(ratio, p);
	return (log - minZ) / range;
}

float linearizeDepth(float z, float n, float f)
{
	return (n * f) / (f - z * (f - n));
}

mat4 ortho(float left, float right, float bottom, float top, float zNear, float zFar)
{
	mat4 result = mat4(vec4(1.0, 0.0, 0.0, 0.0),
					vec4(0.0, 1.0, 0.0, 0.0),
					vec4(0.0, 0.0, 1.0, 0.0),
					vec4(0.0, 0.0, 0.0, 1.0));
					
	result[0][0] = 2.0 / (right - left);
	result[1][1] = 2.0 / (top - bottom);
	result[3][0] = - (right + left) / (right - left);
	result[3][1] = - (top + bottom) / (top - bottom);
	result[2][2] = - 2.0 / (zFar - zNear);
	result[3][2] = - (zFar + zNear) / (zFar - zNear);
	
	mat4 vulkanCorrection =
	mat4(
		vec4( 1.0f, 0.0f, 0.0f, 0.0f),
		vec4( 0.0f, -1.0f, 0.0f, 0.0f),
		vec4( 0.0f, 0.0f, 0.5f, 0.0f),
		vec4( 0.0f, 0.0f, 0.5f, 1.0f)
	);

	return vulkanCorrection * result;
}

void main() 
{
	// extract other data from light view
	
	mat4 lightView = uPushConsts.lightView;
	
	float nearPlane = uPushConsts.lightView[0][3];
	float farPlane = uPushConsts.lightView[1][3];
	float projScaleXInv = uPushConsts.lightView[2][3];
	float projScaleYInv = uPushConsts.lightView[3][0];
	float lightSpaceNear = uPushConsts.lightView[3][1];
	float lightSpaceFar = uPushConsts.lightView[3][2];
	
	lightView[0][3] = 0.0;
	lightView[1][3] = 0.0;
	lightView[2][3] = 0.0;
	lightView[3][0] = 0.0;
	lightView[3][1] = 0.0;
	lightView[3][2] = 0.0;
	
	// get depth bounds in linear space
	float minZ = linearizeDepth(uintBitsToFloat(uMinDepth), nearPlane, farPlane);
	float maxZ = linearizeDepth(uintBitsToFloat(uMaxDepth), nearPlane, farPlane);
	
	uint index = gl_GlobalInvocationID.x;
	
	// calculate split bounds [0 - 1]
	float splitBegin = (index == 0) ? 0.0 : logPartitionFromRange(index - 1, minZ, maxZ);
    float splitEnd = logPartitionFromRange(index, minZ, maxZ);
	
	// extract frustum points
	float nearZ = mix(minZ, maxZ, splitBegin);
	float farZ = mix(minZ, maxZ, splitEnd);

	vec3 corners[8];
	// near corners (in view space)
	float nearX = projScaleXInv * nearZ;
	float nearY = projScaleYInv * nearZ;
	corners[0] = vec3(-nearX, nearY, -nearZ);
	corners[1] = vec3(nearX, nearY, -nearZ);
	corners[2] = vec3(-nearX, -nearY, -nearZ);
	corners[3] = vec3(nearX, -nearY, -nearZ);
	// far corners (in view space)
	float farX = projScaleXInv * farZ;
	float farY = projScaleYInv * farZ;
	corners[4] = vec3(-farX, farY, -farZ);
	corners[5] = vec3(farX, farY, -farZ);
	corners[6] = vec3(-farX, -farY, -farZ);
	corners[7] = vec3(farX, -farY, -farZ);
	
	vec3 minCorner = vec3(3.402823466e+38);
	vec3 maxCorner = -minCorner;
	
	// find min and max corners in light space
	for (uint i = 0; i < 8; ++i)
	{
		vec3 corner = vec3(uPushConsts.cameraViewToLightView * vec4(corners[i], 1.0));
		minCorner = min(minCorner, corner);
		maxCorner = max(maxCorner, corner);
	}

	vec3 center = 0.5 * (minCorner + maxCorner);

	mat4 translation = mat4(vec4(1.0, 0.0, 0.0, 0.0),
							vec4(0.0, 1.0, 0.0, 0.0),
							vec4(0.0, 0.0, 1.0, 0.0),
							vec4(-center.x, -center.y, 0.0, 1.0));
	
	lightView = translation * lightView;
	vec3 dimensions = maxCorner - minCorner;

	uShadowData[index].shadowViewProjectionMatrix = ortho(-dimensions.x * 0.5, 
												dimensions.x * 0.5, 
												-dimensions.y * 0.5, 
												dimensions.y * 0.5, 
												lightSpaceNear, 
												lightSpaceFar)
												* lightView;
}