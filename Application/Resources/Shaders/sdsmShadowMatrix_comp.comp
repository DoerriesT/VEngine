#version 450

#include "sdsmShadowMatrix_bindings.h"
#include "commonSdsm.h"

layout(set = PARTITION_BOUNDS_SET, binding = PARTITION_BOUNDS_BINDING) buffer PARTITION_BOUNDS
{
    uint uMinX[PARTITIONS];
	uint uMinY[PARTITIONS];
	uint uMinZ[PARTITIONS];
	uint uMaxX[PARTITIONS];
	uint uMaxY[PARTITIONS];
	uint uMaxZ[PARTITIONS];
};

layout(set = SHADOW_DATA_SET, binding = SHADOW_DATA_BINDING) buffer SHADOW_DATA
{
    ShadowData uShadowData[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};


layout (local_size_x = PARTITIONS, local_size_y = 1, local_size_z = 1) in;


mat4 ortho(float left, float right, float bottom, float top, float zNear, float zFar)
{
	mat4 result = mat4(vec4(1.0, 0.0, 0.0, 0.0),
					vec4(0.0, 1.0, 0.0, 0.0),
					vec4(0.0, 0.0, 1.0, 0.0),
					vec4(0.0, 0.0, 0.0, 1.0));
					
	result[0][0] = 2.0 / (right - left);
	result[1][1] = 2.0 / (top - bottom);
	result[3][0] = - (right + left) / (right - left);
	result[3][1] = - (top + bottom) / (top - bottom);
	result[2][2] = - 2.0 / (zFar - zNear);
	result[3][2] = - (zFar + zNear) / (zFar - zNear);
	
	mat4 vulkanCorrection =
	mat4(
		vec4( 1.0f, 0.0f, 0.0f, 0.0f),
		vec4( 0.0f, -1.0f, 0.0f, 0.0f),
		vec4( 0.0f, 0.0f, 0.5f, 0.0f),
		vec4( 0.0f, 0.0f, 0.5f, 1.0f)
	);

	return vulkanCorrection * result;
}

void main() 
{
	// extract other data from light view
	
	mat4 lightView = uPushConsts.lightView;

	float lightSpaceNear = uPushConsts.lightView[3][1];
	float lightSpaceFar = uPushConsts.lightView[3][2];
	
	lightView[3][1] = 0.0;
	lightView[3][2] = 0.0;
	
	uint index = gl_GlobalInvocationID.x;
	
	vec3 corners[8];
	{
		vec3 minCornerTmp = vec3(uintBitsToFloat(uMinX[index]), uintBitsToFloat(uMinY[index]), uintBitsToFloat(uMinZ[index]));
		vec3 maxCornerTmp = vec3(uintBitsToFloat(uMaxX[index]), uintBitsToFloat(uMaxY[index]), uintBitsToFloat(uMaxZ[index]));
		vec3 minCorner = min(minCornerTmp, maxCornerTmp);
		vec3 maxCorner = max(minCornerTmp, maxCornerTmp);
		
		corners[0] = vec3(minCorner.x, minCorner.y, minCorner.z);
		corners[1] = vec3(minCorner.x, maxCorner.y, minCorner.z);
		corners[2] = vec3(maxCorner.x, minCorner.y, minCorner.z);
		corners[3] = vec3(maxCorner.x, maxCorner.y, minCorner.z);
		corners[4] = vec3(minCorner.x, minCorner.y, maxCorner.z);
		corners[5] = vec3(minCorner.x, maxCorner.y, maxCorner.z);
		corners[6] = vec3(maxCorner.x, minCorner.y, maxCorner.z);
		corners[7] = vec3(maxCorner.x, maxCorner.y, maxCorner.z);
	}

	vec3 minCorner = vec3(3.402823466e+38);
	vec3 maxCorner = -minCorner;
	
	// find min and max corners in light space
	for (uint i = 0; i < 8; ++i)
	{
		vec4 corner = uPushConsts.cameraViewToLightView * vec4(corners[i].xy * 2.0 - 1.0, corners[i].z, 1.0);
		corner.xyz /= corner.w;
		minCorner = min(minCorner, corner.xyz);
		maxCorner = max(maxCorner, corner.xyz);
	}

	vec3 center = 0.5 * (minCorner + maxCorner);

	mat4 translation = mat4(vec4(1.0, 0.0, 0.0, 0.0),
							vec4(0.0, 1.0, 0.0, 0.0),
							vec4(0.0, 0.0, 1.0, 0.0),
							vec4(-center.x, -center.y, 0.0, 1.0));
	
	lightView = translation * lightView;
	vec3 dimensions = maxCorner - minCorner;
	
	const float border = 0.01;

	uShadowData[index].shadowViewProjectionMatrix = ortho(-dimensions.x * 0.5 - border, 
												dimensions.x * 0.5 + border, 
												-dimensions.y * 0.5 - border, 
												dimensions.y * 0.5 + border, 
												lightSpaceNear, 
												lightSpaceFar)
												* lightView;
}