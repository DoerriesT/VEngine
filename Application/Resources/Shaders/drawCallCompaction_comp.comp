#version 450

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : enable

#include "drawCallCompaction_bindings.h"

struct DrawIndexedIndirectCommand 
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

struct SubMeshData
{
	uint indexCount;
	uint firstIndex;
	int vertexOffset;
};

struct SubMeshInstanceData
{
	uint subMeshIndex;
	uint transformIndex;
	uint materialIndex;
};

layout(set = INDEX_OFFSETS_SET, binding = INDEX_OFFSETS_BINDING) readonly buffer INDEX_OFFSETS 
{
    uint uDrawCallIndexOffsets[];
};

layout(set = INDEX_COUNTS_SET, binding = INDEX_COUNTS_BINDING) readonly buffer INDEX_COUNTS 
{
    uint uDrawCallIndexCounts[];
};

layout(set = INSTANCE_DATA_SET, binding = INSTANCE_DATA_BINDING) readonly buffer INSTANCE_DATA 
{
    SubMeshInstanceData uInstanceData[];
};

layout(set = SUB_MESH_DATA_SET, binding = SUB_MESH_DATA_BINDING) readonly buffer SUB_MESH_DATA 
{
    SubMeshData uSubMeshData[];
};

layout(set = INDIRECT_BUFFER_SET, binding = INDIRECT_BUFFER_BINDING) buffer INDIRECT_BUFFER 
{
    DrawIndexedIndirectCommand uIndirectCommands[];
};

layout(set = DRAW_COUNTS_SET, binding = DRAW_COUNTS_BINDING) buffer DRAW_COUNTS 
{
    uint uDrawCounts[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main() 
{
	const uint drawCallIndex = uPushConsts.drawCallOffset + gl_GlobalInvocationID.x;
	const uint instanceIndex = uPushConsts.instanceOffset + gl_GlobalInvocationID.x;
	
	DrawIndexedIndirectCommand cmd;
	cmd.indexCount = 0;
	
	if (gl_GlobalInvocationID.x < uPushConsts.drawCallCount)
	{
		cmd.indexCount = uDrawCallIndexCounts[drawCallIndex];
		cmd.instanceCount = 1;
		cmd.firstIndex = uDrawCallIndexOffsets[drawCallIndex];
		cmd.vertexOffset = uSubMeshData[uInstanceData[instanceIndex].subMeshIndex].vertexOffset;
		cmd.firstInstance = instanceIndex;
	}
	
	const bool thisInvocationActive = cmd.indexCount > 0;
	uvec4 validBallot = subgroupBallot(thisInvocationActive);
	
	const uint outputCmdCount = subgroupBallotBitCount(validBallot);
	uint localSlot = subgroupBallotExclusiveBitCount(validBallot);
	
	uint globalSlot = 0;
	if (subgroupElect())
	{
		globalSlot = atomicAdd(uDrawCounts[uPushConsts.batchIndex], outputCmdCount);
	}
	
	globalSlot = subgroupBroadcastFirst(globalSlot);
	
	if (thisInvocationActive)
	{
		uIndirectCommands[globalSlot + localSlot] = cmd;
	}
}