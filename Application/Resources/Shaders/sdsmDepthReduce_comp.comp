#version 450

#include "sdsmDepthReduce_bindings.h"
#include "commonSdsm.h"

layout(set = DEPTH_IMAGE_SET, binding = DEPTH_IMAGE_BINDING) uniform sampler2D uDepthImage;

layout(set = DEPTH_BOUNDS_SET, binding = DEPTH_BOUNDS_BINDING) buffer DEPTH_BOUNDS
{
    uint uMinDepth;
	uint uMaxDepth;
};

#define GROUP_SIZE_X 16
#define GROUP_SIZE_Y GROUP_SIZE_X
#define GROUP_SIZE (GROUP_SIZE_X * GROUP_SIZE_Y)

layout (local_size_x = GROUP_SIZE_X, local_size_y = GROUP_SIZE_Y, local_size_z = 1) in;

shared float sMinZ[GROUP_SIZE];
shared float sMaxZ[GROUP_SIZE];

void main() 
{
	const vec2 texelSize = 1.0 / vec2(textureSize(uDepthImage, 0).xy);
	
	float minZ = 1.0;
	float maxZ = 0.0;
	
	
	for (uint y = 0; y < 2; ++y)
	{
		for (uint x = 0; x < 2; ++x)
		{
			vec2 coord = (vec2(gl_GlobalInvocationID.xy) * 4.0 + vec2(x * 2 + 1, y * 2 + 1)) * texelSize;
			vec4 depths = textureGather(uDepthImage, coord);
			
			if (depths[0] != 0.0)
			{
				minZ = min(minZ, depths[0]);
				maxZ = max(maxZ, depths[0]);
			}
			
			if (depths[1] != 0.0)
			{
				minZ = min(minZ, depths[1]);
				maxZ = max(maxZ, depths[1]);
			}
			
			if (depths[2] != 0.0)
			{
				minZ = min(minZ, depths[2]);
				maxZ = max(maxZ, depths[2]);
			}
			
			if (depths[3] != 0.0)
			{
				minZ = min(minZ, depths[3]);
				maxZ = max(maxZ, depths[3]);
			}
		}
	}
	
	const uint localIndex = gl_LocalInvocationID.y * GROUP_SIZE_X + gl_LocalInvocationID.x;
	
	sMinZ[localIndex] = minZ;
    sMaxZ[localIndex] = maxZ;
	
	barrier();
	
	for (uint offset = (GROUP_SIZE >> 1); offset > 0; offset >>= 1) 
	{
        if (localIndex < offset) 
		{
            sMinZ[localIndex] = min(sMinZ[localIndex], sMinZ[offset + localIndex]);
            sMaxZ[localIndex] = max(sMaxZ[localIndex], sMaxZ[offset + localIndex]);
        }
		barrier();
    }
	
	if (localIndex == 0)
	{
		atomicMin(uMinDepth, floatBitsToUint(sMinZ[0]));
		atomicMax(uMaxDepth, floatBitsToUint(sMaxZ[0]));
	}
}