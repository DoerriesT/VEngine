#version 450

#extension GL_EXT_nonuniform_qualifier : enable

#include "screenSpaceVoxelization_bindings.h"

#define DIFFUSE_ONLY 1
#define SHADOW_FUNCTIONS 0
#include "commonLighting.h"

layout(constant_id = DIRECTIONAL_LIGHT_COUNT_CONST_ID) const uint cDirectionalLightCount = 0;

layout(set = VOXEL_IMAGE_SET, binding = VOXEL_IMAGE_BINDING, rgba16f) uniform image3D uVoxelImage;
layout(set = DEPTH_IMAGE_SET, binding = DEPTH_IMAGE_BINDING) uniform sampler2D uDepthImage;
layout(set = UV_IMAGE_SET, binding = UV_IMAGE_BINDING) uniform sampler2D uUVImage;
layout(set = DDXY_LENGTH_IMAGE_SET, binding = DDXY_LENGTH_IMAGE_BINDING) uniform sampler2D uDdxyLengthImage;
layout(set = DDXY_ROT_MATERIAL_ID_IMAGE_SET, binding = DDXY_ROT_MATERIAL_ID_IMAGE_BINDING) uniform usampler2D uDdxyRotMaterialIdImage;
layout(set = TANGENT_SPACE_IMAGE_SET, binding = TANGENT_SPACE_IMAGE_BINDING) uniform usampler2D uTangentSpaceImage;
layout(set = DEFERRED_SHADOW_IMAGE_SET, binding = DEFERRED_SHADOW_IMAGE_BINDING) uniform sampler2D uDeferredShadowImage;

layout(set = DIRECTIONAL_LIGHT_DATA_SET, binding = DIRECTIONAL_LIGHT_DATA_BINDING) readonly buffer DIRECTIONAL_LIGHT_DATA
{
	DirectionalLightData uDirectionalLightData[];
};

layout(set = POINT_LIGHT_DATA_SET, binding = POINT_LIGHT_DATA_BINDING) readonly buffer POINT_LIGHT_DATA
{
	PointLightData uPointLightData[];
};

layout(set = POINT_LIGHT_Z_BINS_SET, binding = POINT_LIGHT_Z_BINS_BINDING) readonly buffer POINT_LIGHT_Z_BINS
{
	uint uPointLightZBins[];
};

layout(set = POINT_LIGHT_MASK_SET, binding = POINT_LIGHT_MASK_BINDING) readonly buffer POINT_LIGHT_BITMASK 
{
	uint uPointLightBitMask[];
};

layout(set = MATERIAL_DATA_SET, binding = MATERIAL_DATA_BINDING) readonly buffer MATERIAL_DATA 
{
    MaterialData uMaterialData[];
};

layout(set = TEXTURES_SET, binding = TEXTURES_BINDING) uniform sampler2D uTextures[TEXTURE_ARRAY_SIZE];

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

float signNotZero(in float k) 
{
    return k >= 0.0 ? 1.0 : -1.0;
}

vec2 signNotZero(in vec2 v) 
{
    return vec2( signNotZero(v.x), signNotZero(v.y) );
}

vec3 decodeNormal(in vec2 enc) 
{
    vec3 v = vec3(enc.x, enc.y, 1.0 - abs(enc.x) - abs(enc.y));
    if (v.z < 0) 
	{
        v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
    }
    return normalize(v);
}

vec4 decodeDerivatives(in uint encodedDerivativesRot, in vec2 derivativesLength)
{
	vec2 derivativesRot;
	derivativesRot.x = float(encodedDerivativesRot.r & 0x7F) * (1.0 / 127.0);
	derivativesRot.y = float((encodedDerivativesRot >> 8) & 0x7F)  * (1.0 / 127.0);
	derivativesRot = derivativesRot * 2.0 - 1.0;
	float signX = (((encodedDerivativesRot.r >> 7u) & 0x1) == 0) ? 1.0 : -1.0;
	float signY = (((encodedDerivativesRot.r >> 15u) & 0x1) == 0) ? 1.0 : -1.0;
	vec4 derivatives;
	derivatives.x = derivativesRot.x;
	derivatives.y = sqrt(1.0 - derivativesRot.x * derivativesRot.x) * signX;
	derivatives.z = derivativesRot.y;
	derivatives.w = sqrt(1.0 - derivativesRot.y * derivativesRot.y) * signY;
	derivatives.xy *= derivativesLength.x;
	derivatives.zw *= derivativesLength.y;
	return derivatives;
}

uint rngState = 0;

uint rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rngState ^= (rngState << 13);
    rngState ^= (rngState >> 17);
    rngState ^= (rngState << 5);
    return rngState;
}

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

void main() 
{
	rngState = wang_hash(gl_GlobalInvocationID.x * floatBitsToInt(uPushConsts.time));
	
	const vec2 texCoord = vec2(rand_xorshift(), rand_xorshift()) * (1.0 / 4294967296.0);
	const ivec2 pixelCoord = ivec2(texCoord * textureSize(uDepthImage, 0).xy);
	
	const float depth = texelFetch(uDepthImage, pixelCoord, 0).x;
	
	if (depth == 0.0)
	{
		return;
	}
	
	// get uv, derivatives, material id and tangent frame
	const vec2 ddxyLength = texelFetch(uDdxyLengthImage, pixelCoord, 0).xy;
	const uvec2 ddxyRotMaterialId = texelFetch(uDdxyRotMaterialIdImage, pixelCoord, 0).xy;
	const uint ddxyRot = ddxyRotMaterialId.x;
	const uint materialId = ddxyRotMaterialId.y;
	const vec4 derivatives = decodeDerivatives(ddxyRot, ddxyLength);
	const uvec2 encodedTBN = texelFetch(uTangentSpaceImage, pixelCoord, 0).xy;
	const vec2 uv = texelFetch(uUVImage, pixelCoord, 0).xy;
	
	const MaterialData materialData = uMaterialData[materialId];
	
	LightingParams lightingParams;
	
	// albedo
	{
		vec3 albedo = unpackUnorm4x8(materialData.albedoOpacity).rgb;
		uint albedoTextureIndex = (materialData.albedoNormalTexture & 0xFFFF0000) >> 16;
		if (albedoTextureIndex != 0)
		{
			vec4 albedoTexSample = textureGrad(uTextures[nonuniformEXT(albedoTextureIndex - 1)], uv, derivatives.xy, derivatives.zw).rgba;
			albedo = albedoTexSample.rgb;
		}
		lightingParams.albedo = accurateSRGBToLinear(albedo);
	}
	
	lightingParams.N = decodeNormal((encodedTBN.xy * (1.0 / 1023.0)) * 2.0 - 1.0);
	lightingParams.metalness = 0.0;
	lightingParams.roughness = 0.5;
	
	// view space position
	const vec4 clipSpacePosition = vec4(vec2(texCoord) * 2.0 - 1.0, depth, 1.0);
	vec4 viewSpacePosition = uPushConsts.invJitteredProjectionMatrix * clipSpacePosition;
	viewSpacePosition /= viewSpacePosition.w;
	
	lightingParams.V = -normalize(viewSpacePosition.xyz);
	lightingParams.viewSpacePosition = viewSpacePosition.xyz;
	
	vec3 result = vec3(0.0);
	
	// ambient
	result += lightingParams.albedo;
	
	// directional lights
	{
		// deferred shadows
		const uint deferredShadowCount = min(4, cDirectionalLightCount);
		const vec4 deferredShadowValues = texelFetch(uDeferredShadowImage, pixelCoord, 0);
		for (uint i = 0; i < deferredShadowCount; ++i)
		{
			const DirectionalLightData directionalLightData = uDirectionalLightData[i];
			const vec3 contribution = evaluateDirectionalLight(lightingParams, directionalLightData);
			result += contribution * (1.0 - deferredShadowValues[i]);
		}
	}
	
	// point lights
	if (uPushConsts.pointLightCount > 0)
	{
		uint wordMin = 0;
		const uint wordCount = (uPushConsts.pointLightCount + 31) / 32;
		uint wordMax = wordCount - 1;
		
		const uint zBinAddress = clamp(uint(floor(-viewSpacePosition.z)), 0, 8191);
		const uint zBinData = uPointLightZBins[zBinAddress];
		const uint minIndex = (zBinData & uint(0xFFFF0000)) >> 16;
		const uint maxIndex = zBinData & uint(0xFFFF);
		wordMin = max(minIndex / 32, wordMin);
		wordMax = min(maxIndex / 32, wordMax);
		const uint address = getTileAddress(uvec2(pixelCoord), uint(textureSize(uDepthImage, 0).x), wordCount);
		
		for (uint wordIndex = wordMin; wordIndex <= wordMax; ++wordIndex)
		{
			uint mask = uPointLightBitMask[address + wordIndex];
			
			// mask by zbin mask
			const int localBaseIndex = int(wordIndex * 32);
			const uint localMin = clamp(int(minIndex) - localBaseIndex, 0, 31);
			const uint localMax = clamp(int(maxIndex) - localBaseIndex, 0, 31);
			const uint maskWidth = localMax - localMin + 1;
			const uint zBinMask = (maskWidth == 32) ? uint(0xFFFFFFFF) : (((1 << maskWidth) - 1) << localMin);
			mask &= zBinMask;
			
			while (mask != 0)
			{
				const uint bitIndex = findLSB(mask);
				const uint index = 32 * wordIndex + bitIndex;
				mask ^= (1 << bitIndex);
				result += evaluatePointLight(lightingParams, uPointLightData[index]);
			}
		}
	}
	
	const mat4 invViewMatrix = transpose(mat4(uPushConsts.invViewMatrixRow0,
												uPushConsts.invViewMatrixRow1,
												uPushConsts.invViewMatrixRow2,
												vec4(0.0, 0.0, 0.0, 1.0)));
	const vec3 worldSpacePos = (invViewMatrix * vec4(lightingParams.viewSpacePosition, 1.0)).xyz;
	
	const ivec3 gridSize = ivec3(imageSize(uVoxelImage).xyz);
	ivec3 voxelCoord = ivec3(round(worldSpacePos * 8.0));
	ivec3 offset = ivec3(round(vec3(invViewMatrix[3]) * 8.0)) - (gridSize / 2);
	voxelCoord -= offset;
	if (all(greaterThanEqual(voxelCoord, ivec3(0))) && all(lessThan(voxelCoord, gridSize)))
	{
		voxelCoord += offset;
		voxelCoord = ivec3(fract(voxelCoord / vec3(gridSize)) * gridSize);
	
		vec4 voxel = imageLoad(uVoxelImage, voxelCoord);
		float weight = voxel.a == 0 ? 1.0 : 0.5 * uPushConsts.deltaTime;
		result = mix(voxel.rgb, result, weight);
		
		imageStore(uVoxelImage, voxelCoord, vec4(result, 1.0));
	}
}