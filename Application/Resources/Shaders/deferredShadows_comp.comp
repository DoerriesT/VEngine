#version 450

#include "deferredShadows_bindings.h"

layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING) uniform writeonly image2D uResultImage;
layout(set = DEPTH_IMAGE_SET, binding = DEPTH_IMAGE_BINDING) uniform sampler2D uDepthImage;
layout(set = TANGENT_SPACE_IMAGE_SET, binding = TANGENT_SPACE_IMAGE_BINDING) uniform usampler2D uTangentSpaceImage;
layout(set = SHADOW_IMAGE_SET, binding = SHADOW_IMAGE_BINDING) uniform texture2DArray uShadowImage;
layout(set = SHADOW_SAMPLER_SET, binding = SHADOW_SAMPLER_BINDING) uniform sampler uShadowSampler;
layout(set = POINT_SAMPLER_SET, binding = POINT_SAMPLER_BINDING) uniform sampler uPointSampler;

layout(set = DIRECTIONAL_LIGHT_DATA_SET, binding = DIRECTIONAL_LIGHT_DATA_BINDING) readonly buffer DIRECTIONAL_LIGHT_DATA
{
	DirectionalLightData uDirectionalLightData[];
};

layout(set = SHADOW_MATRICES_SET, binding = SHADOW_MATRICES_BINDING) readonly buffer SHADOW_MATRICES
{
	mat4 uShadowMatrices[];
};

layout(set = SHADOW_BIAS_BUFFER_SET, binding = SHADOW_BIAS_BUFFER_BINDING) readonly buffer SHADOW_BIAS_BUFFER
{
	vec2 uDepthNormalBias[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(constant_id = DIRECTIONAL_LIGHT_COUNT_CONST_ID) const uint cDirectionalLightCount = 1;
layout(constant_id = WIDTH_CONST_ID) const uint cWidth = 1600;
layout(constant_id = HEIGHT_CONST_ID) const uint cHeight = 900;
layout(constant_id = TEXEL_WIDTH_CONST_ID) const float cTexelWidth = 1.0 / 1600.0;
layout(constant_id = TEXEL_HEIGHT_CONST_ID) const float cTexelHeight = 1.0 / 900;

float interleavedGradientNoise(vec2 v)
{
	vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
	return fract(magic.z * dot(v, magic.xy));
}

vec2 vogelDiskSample(uint sampleIndex, uint samplesCount, float phi)
{
	const float goldenAngle = 2.4;
	const float r = sqrt(sampleIndex + 0.5) / sqrt(samplesCount);
	const float theta = sampleIndex * goldenAngle + phi;

	return vec2(cos(theta), sin(theta)) * r;
}

float avgBlockersDepthToPenumbra(float zShadowMapView, float avgBlockersDepth)
{
	float penumbra = (zShadowMapView - avgBlockersDepth) / avgBlockersDepth;
	penumbra *= penumbra;
	return clamp(4000.0 * penumbra, 0.0, 1.0);
}

float penumbra(float noise, vec4 shadowCoord, int samplesCount, uint layer)
{
	float avgBlockersDepth = 0.0;
	float blockersCount = 0.0;
	
	for (int i = 0; i < samplesCount; ++i)
	{
		const float penumbraFilterMaxSize = 7.0 * (1.0 / 2048.0);
		vec2 sampleCoord = vogelDiskSample(i, samplesCount, noise);
		sampleCoord = shadowCoord.xy + penumbraFilterMaxSize * sampleCoord;
		
		float sampleDepth = texture(sampler2DArray(uShadowImage, uPointSampler), vec3(sampleCoord, layer)).x;
	
		if (sampleDepth < shadowCoord.z)
		{
			avgBlockersDepth += sampleDepth;
			blockersCount += 1.0;
		}
	}
	
	if (blockersCount > 0.0)
	{
		avgBlockersDepth /= blockersCount;
		return avgBlockersDepthToPenumbra(shadowCoord.z, avgBlockersDepth);
	}
	else
	{
		return 0.0;
	}
}

float signNotZero(in float k) 
{
    return k >= 0.0 ? 1.0 : -1.0;
}

vec2 signNotZero(in vec2 v) 
{
    return vec2( signNotZero(v.x), signNotZero(v.y) );
}

vec3 decodeNormal(in vec2 enc) 
{
    vec3 v = vec3(enc.x, enc.y, 1.0 - abs(enc.x) - abs(enc.y));
    if (v.z < 0) 
	{
        v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
    }
    return normalize(v);
}

void main() 
{
	if (gl_GlobalInvocationID.x >= cWidth || gl_GlobalInvocationID.y >=  cHeight)
	{
		return;
	}
	const float depth = texelFetch(uDepthImage, ivec2(gl_GlobalInvocationID.xy), 0).x;
	if (depth == 0.0)
	{
		imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(0.0));
		return;
	}
	
	const uvec2 encodedTBN = texelFetch(uTangentSpaceImage, ivec2(gl_GlobalInvocationID.xy), 0).xy;
	const vec4 viewSpaceNormal = vec4(decodeNormal((encodedTBN.xy * (1.0 / 1023.0)) * 2.0 - 1.0), 0.0);
	const vec3 N = (uPushConsts.invViewMatrix * viewSpaceNormal).xyz;
	
	const vec2 texCoord = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) * vec2(cTexelWidth, cTexelHeight);
	vec4 worldSpacePos = uPushConsts.invViewProjectionMatrix * vec4(texCoord * 2.0 - 1.0, depth, 1.0);
	worldSpacePos *= 1.0 / worldSpacePos.w;
	
	vec4 shadow = vec4(0.0);
	
	for (uint lightIdx = 0; lightIdx < cDirectionalLightCount; ++lightIdx)
	{
		const uint shadowDataOffsetCount = uDirectionalLightData[lightIdx].shadowDataOffsetCount;
		const uint offset = shadowDataOffsetCount >> 16;
		const uint end = (shadowDataOffsetCount & 0xFFFF) + offset;
		uint layerIdx = offset;
		vec4 shadowCoord;
		
		const float NdotL = dot(viewSpaceNormal.xyz, uDirectionalLightData[lightIdx].direction.xyz);
		
		if (NdotL <= 0.0)
		{
			shadow[lightIdx] = 1.0;
			continue;
		}
		
		const float scaleWeight = 1.0 - max(NdotL, 0.0);
	
		// find cascade and evaluate shadow
		for (; layerIdx < end; ++layerIdx)
		{
			const float normalOffsetScale = uDepthNormalBias[layerIdx].y * scaleWeight;
			shadowCoord = uShadowMatrices[layerIdx] * vec4(worldSpacePos.xyz + N * normalOffsetScale, 1.0);
			if (all(lessThan(abs(shadowCoord.xy), vec2(1.0))))
			{
				break;
			}
		}
		
		if (layerIdx < end)
		{
			shadowCoord.xy = shadowCoord.xy * 0.5 + 0.5;
			shadowCoord.z += uDepthNormalBias[layerIdx].x;
			shadow[lightIdx] = texture(sampler2DArrayShadow(uShadowImage, uShadowSampler), vec4(shadowCoord.xy, layerIdx, shadowCoord.z)).x;
		}
	}
	
	imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), shadow);
}