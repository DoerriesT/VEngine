#version 450

#include "deferredShadows_bindings.h"

layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING) uniform writeonly image2D uResultImage;
layout(set = DEPTH_IMAGE_SET, binding = DEPTH_IMAGE_BINDING) uniform sampler2D uDepthImage;
layout(set = SHADOW_IMAGE_SET, binding = SHADOW_IMAGE_BINDING) uniform texture2DArray uShadowImage;
layout(set = SHADOW_SAMPLER_SET, binding = SHADOW_SAMPLER_BINDING) uniform sampler uShadowSampler;
layout(set = POINT_SAMPLER_SET, binding = POINT_SAMPLER_BINDING) uniform sampler uPointSampler;

layout(set = DIRECTIONAL_LIGHT_DATA_SET, binding = DIRECTIONAL_LIGHT_DATA_BINDING) readonly buffer DIRECTIONAL_LIGHT_DATA
{
	DirectionalLightData uDirectionalLightData[];
};

layout(set = SHADOW_MATRICES_SET, binding = SHADOW_MATRICES_BINDING) readonly buffer SHADOW_MATRICES
{
	mat4 uShadowMatrices[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(constant_id = DIRECTIONAL_LIGHT_COUNT_CONST_ID) const uint cDirectionalLightCount = 1;
layout(constant_id = WIDTH_CONST_ID) const uint cWidth = 1600;
layout(constant_id = HEIGHT_CONST_ID) const uint cHeight = 900;
layout(constant_id = TEXEL_WIDTH_CONST_ID) const float cTexelWidth = 1.0 / 1600.0;
layout(constant_id = TEXEL_HEIGHT_CONST_ID) const float cTexelHeight = 1.0 / 900;

float interleavedGradientNoise(vec2 v)
{
	vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
	return fract(magic.z * dot(v, magic.xy));
}

vec2 vogelDiskSample(uint sampleIndex, uint samplesCount, float phi)
{
	const float goldenAngle = 2.4;
	const float r = sqrt(sampleIndex + 0.5) / sqrt(samplesCount);
	const float theta = sampleIndex * goldenAngle + phi;

	return vec2(cos(theta), sin(theta)) * r;
}

float avgBlockersDepthToPenumbra(float zShadowMapView, float avgBlockersDepth)
{
	float penumbra = (zShadowMapView - avgBlockersDepth) / avgBlockersDepth;
	penumbra *= penumbra;
	return clamp(4000.0 * penumbra, 0.0, 1.0);
}

float penumbra(float noise, vec4 shadowCoord, int samplesCount, uint layer)
{
	float avgBlockersDepth = 0.0;
	float blockersCount = 0.0;
	
	for (int i = 0; i < samplesCount; ++i)
	{
		const float penumbraFilterMaxSize = 7.0 * (1.0 / 2048.0);
		vec2 sampleCoord = vogelDiskSample(i, samplesCount, noise);
		sampleCoord = shadowCoord.xy + penumbraFilterMaxSize * sampleCoord;
		
		float sampleDepth = texture(sampler2DArray(uShadowImage, uPointSampler), vec3(sampleCoord, layer)).x;
	
		if (sampleDepth < shadowCoord.z)
		{
			avgBlockersDepth += sampleDepth;
			blockersCount += 1.0;
		}
	}
	
	if (blockersCount > 0.0)
	{
		avgBlockersDepth /= blockersCount;
		return avgBlockersDepthToPenumbra(shadowCoord.z, avgBlockersDepth);
	}
	else
	{
		return 0.0;
	}
}

void main() 
{
	if (gl_GlobalInvocationID.x >= cWidth || gl_GlobalInvocationID.y >=  cHeight)
	{
		return;
	}
	const float depth = texelFetch(uDepthImage, ivec2(gl_GlobalInvocationID.xy), 0).x;
	if (depth == 0.0)
	{
		imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(0.0));
		return;
	}
	const vec2 texCoord = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) * vec2(cTexelWidth, cTexelHeight);
	vec4 worldSpacePos = uPushConsts.invViewProjectionMatrix * vec4(texCoord * 2.0 - 1.0, depth, 1.0);
	worldSpacePos *= 1.0 / worldSpacePos.w;
	
	vec4 shadow = vec4(0.0);
	
	for (uint lightIdx = 0; lightIdx < cDirectionalLightCount; ++lightIdx)
	{
		const uint shadowDataOffsetCount = uDirectionalLightData[lightIdx].shadowDataOffsetCount;
		const uint offset = shadowDataOffsetCount >> 16;
		const uint end = (shadowDataOffsetCount & 0xFFFF) + offset;
	
		// find cascade and evaluate shadow
		for (uint i = offset; i < end; ++i)
		{
			vec4 shadowCoord = uShadowMatrices[i] * worldSpacePos;
			shadowCoord.xy = shadowCoord.xy * 0.5 + 0.5;
			const float border = 7.0 * (1.0 / 2048.0);
			if (shadowCoord.x < (0.0 + border) || shadowCoord.x > (1.0 - border) || shadowCoord.y < (0.0 + border) || shadowCoord.y > (1.0 - border))
			{
				continue;
			}
			shadowCoord.z -= 0.0001;
			const float noise = interleavedGradientNoise(vec2(gl_GlobalInvocationID.xy) + 0.5);
			const float filterScale = penumbra(noise, shadowCoord, 16, i);
			for (uint j = 0; j < 16; ++j)
			{
				const vec2 coord = filterScale * border * vogelDiskSample(j, 16, noise) + shadowCoord.xy;
				shadow[lightIdx] += texture(sampler2DArrayShadow(uShadowImage, uShadowSampler), vec4(coord, i, shadowCoord.z)).x * (1.0 / 16.0);
			}
			break;
		}
	}
	
	imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), shadow);
}