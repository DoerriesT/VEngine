#version 450

#include "voxelDebug2_bindings.h"

layout(constant_id = VOXEL_GRID_WIDTH_CONST_ID) const uint cVoxelGridWidth = 128;
layout(constant_id = VOXEL_GRID_HEIGHT_CONST_ID) const uint cVoxelGridHeight = 64;
layout(constant_id = VOXEL_GRID_DEPTH_CONST_ID) const uint cVoxelGridDepth = 128;
layout(constant_id = WIDTH_CONST_ID) const uint cWidth = 1600;
layout(constant_id = HEIGHT_CONST_ID) const uint cHeight = 900;
layout(constant_id = TEXEL_WIDTH_CONST_ID) const float cTexelWidth = 1.0 / 1600.0;
layout(constant_id = TEXEL_HEIGHT_CONST_ID) const float cTexelHeight = 1.0 / 900;

layout(set = OPACITY_IMAGE_SET, binding = OPACITY_IMAGE_BINDING) uniform sampler3D uOpacityImage;
layout(set = VOXEL_IMAGE_SET, binding = VOXEL_IMAGE_BINDING) uniform sampler3D uVoxelImage;
layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING, rgba16f) uniform writeonly image2D uResultImage;

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

const ivec3 gridSize = ivec3(cVoxelGridWidth, cVoxelGridHeight, cVoxelGridDepth);

vec4 raymarch(vec3 p0, vec3 dir, ivec3 offset)
{
	// grid space
	vec3 gridCoord = floor(p0);
	const vec3 gridStep = sign(dir);
	const vec3 corner = max(gridStep, vec3(0.0));
	const vec3 invGridSize = 1.0 / vec3(gridSize);
	
	// ray space
	const vec3 inv = 1.0 / dir;
	vec3 ratio = (gridCoord + corner - p0) * inv;
	const vec3 ratioStep = gridStep * inv;
	
	const int cascade = uPushConsts.cascade;
	
	// dda
	while (true) 
	{
		if (any(lessThan(gridCoord, offset)) || any(greaterThanEqual(gridCoord, gridSize + offset)))
		{
			return vec4(0.0);
		}
		
		ivec3 coord = ivec3(fract(gridCoord * invGridSize) * gridSize);
		// cascades are stacked on top of each other inside the same image
		coord += ivec3(0, cascade * cVoxelGridHeight, 0);
		// z and y axis are switched in order to "grow" the image along the z axis with each additional cascade
		coord = coord.xzy;
		
		if (texelFetch(uOpacityImage, coord, 0).x > 0.0)
		{
			return texelFetch(uVoxelImage, coord, 0);
		}
	
		const ivec3 mask = ivec3(lessThanEqual(ratio.xyz, min(ratio.yzx, ratio.zxy)));
		gridCoord += gridStep  * mask;		
		ratio += ratioStep * mask;
	}
}

void main() 
{
	if (gl_GlobalInvocationID.x >= cWidth || gl_GlobalInvocationID.y >= cHeight)
	{
		return;
	}
	
	vec4 worldSpacePos = uPushConsts.invViewProjection * vec4(vec2(gl_GlobalInvocationID.xy) * vec2(cTexelWidth, cTexelHeight) * 2.0 - 1.0, 1.0, 1.0);
	worldSpacePos.xyz /= worldSpacePos.w;
	
	vec4 direction4 = uPushConsts.invViewProjection * vec4(vec2(gl_GlobalInvocationID.xy) * vec2(cTexelWidth, cTexelHeight) * 2.0 - 1.0, 0.0, 1.0);
	vec3 direction = normalize(direction4.xyz / direction4.w - worldSpacePos.xyz);
	
	// world space offset of grid (grid is centered on camera)
	ivec3 offset = ivec3(round(vec3(uPushConsts.cameraPos) * uPushConsts.voxelScale)) - (gridSize / 2);
	vec4 c = raymarch(vec3(worldSpacePos.xyz * uPushConsts.voxelScale + 0.5), direction, offset);
	
	if (c.a > 0.0)
	{
		imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), c);
	}
}