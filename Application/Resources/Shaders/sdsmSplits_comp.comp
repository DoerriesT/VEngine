#version 450

#include "sdsmSplits_bindings.h"
#include "commonSdsm.h"

layout(set = DEPTH_BOUNDS_SET, binding = DEPTH_BOUNDS_BINDING) buffer DEPTH_BOUNDS
{
    uint uMinDepth;
	uint uMaxDepth;
};

layout(set = SPLITS_SET, binding = SPLITS_BINDING) buffer SPLITS
{
	float uSplits[PARTITIONS * 2]; // even is begin, odd is end
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = PARTITIONS, local_size_y = 1, local_size_z = 1) in;


float logPartitionFromRange(uint split, float minZ, float maxZ)
{
	float ratio = maxZ / minZ;
    float p = (split + 1) / float(PARTITIONS);
	return minZ * pow(ratio, p);
}

float linearizeDepth(float z, float n, float f)
{
	z = 1.0 - z;
	return (n * f) / (f - z * (f - n));
}

void main() 
{
	float nearPlane = uPushConsts.nearPlane;
	float farPlane = uPushConsts.farPlane;
	
	// get depth bounds in linear space
	float minZ = linearizeDepth(uintBitsToFloat(uMaxDepth), nearPlane, farPlane);
	float maxZ = linearizeDepth(uintBitsToFloat(uMinDepth), nearPlane, farPlane);
	
	const uint index = gl_GlobalInvocationID.x;
	
	// calculate split bounds [minZ - maxZ]
	float splitBegin = (index == 0) ? minZ : logPartitionFromRange(index - 1, minZ, maxZ);
    float splitEnd = logPartitionFromRange(index, minZ, maxZ);
	
	uSplits[index * 2] = splitBegin;
	uSplits[index * 2 + 1] = splitEnd;
}