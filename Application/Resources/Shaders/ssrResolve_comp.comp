#version 450

#include "ssrResolve_bindings.h"
#include "common.h"

layout(constant_id = WIDTH_CONST_ID) const uint cWidth = 1600;
layout(constant_id = HEIGHT_CONST_ID) const uint cHeight = 900;
layout(constant_id = TEXEL_WIDTH_CONST_ID) const float cTexelWidth = 1.0 / 1600.0;
layout(constant_id = TEXEL_HEIGHT_CONST_ID) const float cTexelHeight = 1.0 / 900;

layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING, rgba16f) uniform writeonly image2D uResultImage;
layout(set = RAY_HIT_PDF_IMAGE_SET, binding = RAY_HIT_PDF_IMAGE_BINDING) uniform sampler2D uRayHitPdfImage;
layout(set = MASK_IMAGE_SET, binding = MASK_IMAGE_BINDING) uniform sampler2D uMaskImage;
layout(set = NORMAL_IMAGE_SET, binding = NORMAL_IMAGE_BINDING) uniform sampler2D uNormalImage;
layout(set = DEPTH_IMAGE_SET, binding = DEPTH_IMAGE_BINDING) uniform sampler2D uDepthImage;
layout(set = PREV_COLOR_IMAGE_SET, binding = PREV_COLOR_IMAGE_BINDING) uniform sampler2D uPrevColorImage;
layout(set = VELOCITY_IMAGE_SET, binding = VELOCITY_IMAGE_BINDING) uniform sampler2D uVelocityImage;

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a2 = roughness*roughness;
    a2 *= a2;
    float NdotH2 = max(dot(N, H), 0.0);
    NdotH2 *= NdotH2;

    float nom   = a2;
    float denom = NdotH2 * (a2 - 1.0) + 1.0;

    denom = PI * denom * denom;

    return nom / max(denom, 0.0000001);
}

float GeometrySmith(float NdotV, float NdotL, float roughness)
{
	float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float ggx2 =  NdotV / max(NdotV * (1.0 - k) + k, 0.0000001);
    float ggx1 = NdotL / max(NdotL * (1.0 - k) + k, 0.0000001);

    return ggx1 * ggx2;
}

float localBrdf(vec3 N, vec3 V, vec3 L, float roughness)
{
	float NdotV = max(dot(N, V), 0.0);
	float NdotL = max(dot(N, L), 0.0);
	vec3 H = normalize(L + V);
	return max(DistributionGGX(N, H, roughness) * GeometrySmith(NdotV, NdotL, roughness), 0.0);
}

void main() 
{
	if (gl_GlobalInvocationID.x >= cWidth || gl_GlobalInvocationID.y >= cHeight)
	{
		return;
	}
	
	const float depth = texelFetch(uDepthImage, ivec2(gl_GlobalInvocationID.xy), 0).x;
	if (depth == 0.0)
	{
		return;
	}
	
	const vec2 clipSpacePosition = vec2(gl_GlobalInvocationID.xy + 0.5) * vec2(cTexelWidth, cTexelHeight) * 2.0 - 1.0;
	vec4 viewSpacePosition = vec4(uPushConsts.unprojectParams.xy * clipSpacePosition, -1.0, uPushConsts.unprojectParams.z * depth + uPushConsts.unprojectParams.w);
	viewSpacePosition.xyz /= viewSpacePosition.w;
	
	const vec3 P = viewSpacePosition.xyz;
	const vec3 V = -normalize(viewSpacePosition.xyz);
	vec4 normalRoughness = texelFetch(uNormalImage, ivec2(gl_GlobalInvocationID.xy), 0);
	const vec3 N = normalRoughness.xyz;
	const float roughness = normalRoughness.w;
	
	// process rays
	float totalWeight = 0.0;
	vec4 result = vec4(0.0);
	{
		vec4 rayHitPdf = texelFetch(uRayHitPdfImage, ivec2(gl_GlobalInvocationID.xy), 0);
		float mask = texelFetch(uMaskImage, ivec2(gl_GlobalInvocationID.xy), 0).x;
		mask *= (rayHitPdf.x > 0.0 && rayHitPdf.y > 0.0 && rayHitPdf.x < 1.0 && rayHitPdf.y < 1.0 && rayHitPdf.z < 1.0) ? 1.0 : 0.0;
		
		vec4 viewSpaceHitPos = vec4(uPushConsts.unprojectParams.xy * (rayHitPdf.xy * 2.0 - 1.0), -1.0, uPushConsts.unprojectParams.z * rayHitPdf.z + uPushConsts.unprojectParams.w);
		viewSpaceHitPos.xyz /= viewSpaceHitPos.w;
		vec3 L = normalize(viewSpaceHitPos.xyz - P);
		
		float weight = /*localBrdf(N, V, L, roughness)*/ 1.0 / max(rayHitPdf.w, 1e-6);
		vec4 sampleColor = vec4(0.0, 0.0, 0.0, mask);
		if (sampleColor.a > 0.0)
		{
			// reproject into last frame
			vec2 velocity = textureLod(uVelocityImage, rayHitPdf.xy, 0.0).xy;
			rayHitPdf.xy -= velocity;
			
			// is the uv coord still valid?
			sampleColor.a *= (rayHitPdf.x > 0.0 && rayHitPdf.y > 0.0 && rayHitPdf.x < 1.0 && rayHitPdf.y < 1.0) ? 1.0 : 0.0;
			
			sampleColor.rgb = sampleColor.a > 0.0 ? textureLod(uPrevColorImage, rayHitPdf.xy, 0.0).rgb : vec3(0.0);
		}
		
		result += sampleColor * weight;
		totalWeight += weight;
	}
	
	result *= 1.0 / max(totalWeight, 1e-6);
	
	imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), result);
}