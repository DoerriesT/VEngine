#version 450

#define MAX_POINT_LIGHT_WORDS 2048
#define TILE_SIZE (16)
#define NUM_THREADS (TILE_SIZE * TILE_SIZE)

layout (local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

layout(push_constant) uniform PushConsts 
{
	uint pointLightCount;
} uPushConsts;

layout(set = 0, binding = 0) uniform PerFrameData 
{
	float time;
	float fovy;
	float nearPlane;
	float farPlane;
	mat4 viewMatrix;
	mat4 projectionMatrix;
	mat4 viewProjectionMatrix;
	mat4 invViewMatrix;
	mat4 invProjectionMatrix;
	mat4 invViewProjectionMatrix;
	mat4 prevViewMatrix;
	mat4 prevProjectionMatrix;
	mat4 prevViewProjectionMatrix;
	mat4 prevInvViewMatrix;
	mat4 prevInvProjectionMatrix;
	mat4 prevInvViewProjectionMatrix;
	vec4 cameraPosition;
	vec4 cameraDirection;
	uint frame;
} uPerFrameData;

layout(set = 1, binding = 0) buffer PointLightBitMask 
{
	uint mask[];
} uPointLightBitMask;

layout(set = 2, binding = 0) readonly buffer PointLightCullData 
{
	vec4 spheres[];
} uPointLightCullData;

struct Ray
{
	vec3 origin;
	vec3 dir;
};

bool intersectRaySphere(inout Ray ray, vec4 sphere)
{
	vec3 l = sphere.xyz - ray.origin;
	float s = dot(l, ray.dir);
	float l2 = dot(l, l);
	float m2 = l2 - s * s;
	float r2 = sphere.w * sphere.w;
	return !((s < 0 && l2 > r2) || (m2 > r2));
}

shared uint pointLightMaskLds[MAX_POINT_LIGHT_WORDS];

void main() 
{
	vec4 p[8];
	// near
	p[0] = vec4(TILE_SIZE * vec2(gl_WorkGroupID.xy), 0.0, 1.0);
	p[1] = vec4(TILE_SIZE * vec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y), 0.0, 1.0);
	p[2] = vec4(TILE_SIZE * vec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y + 1), 0.0, 1.0);
	p[3] = vec4(TILE_SIZE * vec2(gl_WorkGroupID.x, gl_WorkGroupID.y + 1), 0.0, 1.0);
	
	// far
	p[4] = vec4(TILE_SIZE * vec2(gl_WorkGroupID.xy), 1.0, 1.0);
	p[5] = vec4(TILE_SIZE * vec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y), 1.0, 1.0);
	p[6] = vec4(TILE_SIZE * vec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y + 1), 1.0, 1.0);
	p[7] = vec4(TILE_SIZE * vec2(gl_WorkGroupID.x, gl_WorkGroupID.y + 1), 1.0, 1.0);
	
	vec2 invRes = 1.0 / (TILE_SIZE * vec2(gl_NumWorkGroups.xy));
	
	for (uint i = 0; i < 8; ++i)
	{
		p[i].xy = p[i].xy * invRes * 2.0 - 1.0;; 
		p[i] = uPerFrameData.invProjectionMatrix * p[i];
		p[i].xyz /= p[i].w;
	}
	Ray rays[4];
	
	for (uint i = 0; i < 4; ++i)
	{
		rays[i].origin = p[i].xyz;
		rays[i].dir = normalize(p[i + 4].xyz - p[i].xyz);
	}
	
	if ((gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x) == 0)
	{
		for (uint i = 0; i < MAX_POINT_LIGHT_WORDS; ++i)
		{
			pointLightMaskLds[i] = 0;
		}
	}
	
	memoryBarrierShared();
	barrier();
	
	uint localIndex = gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x;
	uint pointLightCount = uPushConsts.pointLightCount;
	uint totalWords = pointLightCount / 32 + ((pointLightCount % 32 == 0) ? 0 : 1);
	
	for (uint word = localIndex; word < totalWords; word += NUM_THREADS)
	{
		for (uint i = word * 32; i < pointLightCount && i < word * 32 + 32; ++i)
		{
			vec4 p = uPointLightCullData.spheres[i];
			
			//Test if sphere is intersecting or inside frustum
			if (intersectRaySphere(rays[0], p) ||
				intersectRaySphere(rays[1], p) ||
				intersectRaySphere(rays[2], p) ||
				intersectRaySphere(rays[3], p))
			{
				pointLightMaskLds[i / 32] |= 1 << (i % 32);	
			}
		}
	}
	
	memoryBarrierShared();
	barrier();
	
	if ((gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x) == 0)
	{
		uint tileOffset = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
		for (uint i = 0; i < MAX_POINT_LIGHT_WORDS; ++i)
		{
			uPointLightBitMask.mask[tileOffset * MAX_POINT_LIGHT_WORDS + i] = pointLightMaskLds[i];
		}
	}
}