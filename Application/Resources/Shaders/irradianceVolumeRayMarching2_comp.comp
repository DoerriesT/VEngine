#version 450

#include "irradianceVolumeRayMarching2_bindings.h"
#include "common.h"

layout(set = BRICK_PTR_IMAGE_SET, binding = BRICK_PTR_IMAGE_BINDING) uniform usampler3D uBrickPtrImage;
layout(set = BIN_VIS_IMAGE_BUFFER_SET, binding = BIN_VIS_IMAGE_BUFFER_BINDING) uniform usamplerBuffer uBinVisImageBuffer;
layout(set = COLOR_IMAGE_BUFFER_SET, binding = COLOR_IMAGE_BUFFER_BINDING) uniform samplerBuffer uColorImageBuffer;
layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING, rgba16f) uniform image2D uResultImage;
layout(set = DISTANCE_IMAGE_SET, binding = DISTANCE_IMAGE_BINDING, r16f) uniform image2D uDistanceImage;

layout(set = QUEUE_BUFFER_SET, binding = QUEUE_BUFFER_BINDING) readonly buffer QUEUE_BUFFER
{
	uint uQueueSize;
	float uP;
	uint uQueue[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout(constant_id = GRID_WIDTH_CONST_ID) const uint cGridWidth = 64;
layout(constant_id = GRID_HEIGHT_CONST_ID) const uint cGridHeight = 32;
layout(constant_id = GRID_DEPTH_CONST_ID) const uint cGridDepth = 64;
layout(constant_id = CASCADES_CONST_ID) const uint cCascades = 3;
layout(constant_id = GRID_BASE_SCALE_CONST_ID) const float cGridBaseScale = 2.0;
layout(constant_id = BRICK_VOLUME_WIDTH_CONST_ID) const uint cBrickVolumeWidth = 128;
layout(constant_id = BRICK_VOLUME_HEIGHT_CONST_ID) const uint cBrickVolumeHeight = 64;
layout(constant_id = BRICK_VOLUME_DEPTH_CONST_ID) const uint cBrickVolumeDepth = 128;
layout(constant_id = VOXEL_GRID_WIDTH_CONST_ID) const uint cVoxelGridWidth = 2048;
layout(constant_id = VOXEL_GRID_HEIGHT_CONST_ID) const uint cVoxelGridHeight = 1024;
layout(constant_id = VOXEL_GRID_DEPTH_CONST_ID) const uint cVoxelGridDepth = 2048;
layout(constant_id = VOXEL_SCALE_CONST_ID) const float cVoxelScale = 16.0;
layout(constant_id = BIN_VIS_BRICK_SIZE_CONST_ID) const uint cBinVisBrickSize = 16;
layout(constant_id = COLOR_BRICK_SIZE_CONST_ID) const uint cColorBrickSize = 4;


layout (local_size_x = IRRADIANCE_VOLUME_RAY_MARCHING_RAY_COUNT, local_size_y = 1, local_size_z = 1) in;


/**  Generate a spherical fibonacci point

    http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/

    To generate a nearly uniform point distribution on the unit sphere of size N, do
    for (float i = 0.0; i < N; i += 1.0) {
        float3 point = sphericalFibonacci(i,N);
    }

    The points go from z = +1 down to z = -1 in a spiral. To generate samples on the +z hemisphere,
    just stop before i > N/2.

*/
vec3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * PI * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(clamp(1.0 - cosTheta * cosTheta, 0.0, 1.0));

    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}

uint rand_xorshift(uint rngState)
{
    // Xorshift algorithm from George Marsaglia's paper
    rngState ^= (rngState << 13);
    rngState ^= (rngState >> 17);
    rngState ^= (rngState << 5);
    return rngState;
}

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

mat3 randomOrientation()
{
	uint rngState = wang_hash(floatBitsToInt(uPushConsts.time));
	vec3 axis = normalize(vec3(rand_xorshift(rngState), rand_xorshift(rngState), rand_xorshift(rngState)) * (1.0 / 4294967296.0));
	float angle = rand_xorshift(rngState) * (1.0 / 4294967296.0) * 2.0 * PI;

	mat3 m;
	float c = cos(angle);
	float s = sin(angle);
	float oneMinusCos = 1.0 - c;
	float x2 = axis.x * axis.x;
	float y2 = axis.y * axis.y;
	float z2 = axis.z * axis.z;
	float xym = axis.x * axis.y * oneMinusCos;
	float xzm = axis.x * axis.z * oneMinusCos;
	float yzm = axis.y * axis.z * oneMinusCos;
	float xSin = axis.x * s;
	float ySin = axis.y * s;
	float zSin = axis.z * s;

	m[0][0] = x2 * oneMinusCos + c;
	m[0][1] = xym - zSin;
	m[0][2] = xzm + ySin;

	m[1][0] = xym + zSin;
	m[1][1] = y2 * oneMinusCos + c;
	m[1][2] = yzm - xSin;

	m[2][0] = xzm - ySin;
	m[2][1] = yzm + xSin;
	m[2][2] = z2 * oneMinusCos + c;

	return m;
}

const ivec3 gridSize = ivec3(cVoxelGridWidth, cVoxelGridHeight, cVoxelGridDepth);

bool fetchVisibility(ivec3 coord, out vec3 color)
{
	const vec3 brickGridSize = vec3(cBrickVolumeWidth, cBrickVolumeHeight, cBrickVolumeDepth);
	const vec3 invBrickGridSize = 1.0 / brickGridSize;
	
	ivec3 brickCoord = ivec3(fract(floor(vec3(coord) / float(cBinVisBrickSize)) * invBrickGridSize) * brickGridSize);
	uint brickPtr = texelFetch(uBrickPtrImage, brickCoord, 0).x;
	
	if (brickPtr != 0)
	{
		ivec3 localCoord = ivec3(fract(vec3(coord) / float(cBinVisBrickSize)) * cBinVisBrickSize);
		ivec3 cubeCoord = localCoord / 4;
		float cubesPerBrick = cBinVisBrickSize * 0.25;
		ivec3 localCubeCoord = ivec3(fract(cubeCoord / cubesPerBrick) * cubesPerBrick);
		uint cubeIdx = localCubeCoord.x + localCubeCoord.z * 4 + localCubeCoord.y * 16;
		ivec3 bitCoord = ivec3(fract(localCoord / 4.0) * 4.0);
		uint bitIdx = bitCoord.x + bitCoord.z * 4 + bitCoord.y * 16;
		bool upper = bitIdx > 31;
		bitIdx = upper ? bitIdx - 32 : bitIdx;
		
		const uint binVisBrickMemSize = (cBinVisBrickSize * cBinVisBrickSize * cBinVisBrickSize) / 32;
		uint binVis = texelFetch(uBinVisImageBuffer, int((brickPtr - 1) * binVisBrickMemSize + cubeIdx * 2 + (upper ? 1 : 0))).x;
		if ((binVis & (1u << bitIdx)) != 0)
		{
			const uint colorBrickMemSize = (cColorBrickSize * cColorBrickSize * cColorBrickSize);
			const ivec3 localColorCoord = ivec3(localCoord / float(cBinVisBrickSize) * cColorBrickSize);
			const uint colorIdx = localColorCoord.x + localColorCoord.z * cColorBrickSize + localColorCoord.y * cColorBrickSize * cColorBrickSize;
			color = texelFetch(uColorImageBuffer, int((brickPtr - 1) * colorBrickMemSize + colorIdx)).rgb;
			return true;
		}
		return false;
	}
	else
	{
		return false;
	}
}

vec4 raymarch(vec3 worldSpacePos, vec3 dir, out float dist)
{
	// world space offset of grid (grid is centered on camera)
	//ivec3 offset = ivec3(round(vec3(uPushConsts.cameraPosition) * cVoxelScale)) - (gridSize / 2);
	vec3 p0 = worldSpacePos.xyz * cVoxelScale + 0.5;
	
	// grid space
	vec3 gridCoord = floor(p0);
	const vec3 gridStep = sign(dir);
	const vec3 corner = max(gridStep, vec3(0.0));
	const vec3 invGridSize = 1.0 / vec3(gridSize);
	
	// ray space
	const vec3 inv = 1.0 / dir;
	vec3 ratio = (gridCoord + corner - p0) * inv;
	const vec3 ratioStep = gridStep * inv;
	
	// dda
	while (true) 
	{
		if (any(lessThan(gridCoord, uPushConsts.voxelGridOffset)) || any(greaterThanEqual(gridCoord, gridSize + uPushConsts.voxelGridOffset)))
		{
			return vec4(0.0);
		}
		
		vec3 color;
		if (fetchVisibility(ivec3(gridCoord), color))
		{
			dist = distance(worldSpacePos, gridCoord / cVoxelScale);
			return vec4(color, 1.0);
		}
	
		const ivec3 mask = ivec3(lessThanEqual(ratio.xyz, min(ratio.yzx, ratio.zxy)));
		gridCoord += gridStep  * mask;		
		ratio += ratioStep * mask;
	}
}

void main() 
{
	const ivec3 gridSize = ivec3(cGridWidth, cGridHeight, cGridDepth);
	
	// get cell index and cascade index
	uint cellIndex = uQueue[gl_WorkGroupID.x];
	const uint cascade = cellIndex / (cGridWidth * cGridHeight * cGridDepth);
	cellIndex -= cascade * (cGridWidth * cGridHeight * cGridDepth);
	
	// get cell coordinate
	ivec3 cellCoord;
	cellCoord.y = int(cellIndex / (gridSize.x * gridSize.z));
	cellCoord.x = int(cellIndex % gridSize.x);
	cellCoord.z = int((cellIndex - cellCoord.y * (gridSize.x * gridSize.z)) / gridSize.x);
	
	ivec3 gridOffset = ivec3(round(uPushConsts.cameraPosition.xyz * (cGridBaseScale / (1 << cascade)))) - gridSize / 2;
	const vec3 worldSpacePos = vec3(cellCoord + gridOffset) / (cGridBaseScale / (1 << cascade));
	
	const vec3 dir = randomOrientation() * sphericalFibonacci(float(gl_LocalInvocationID.x), IRRADIANCE_VOLUME_RAY_MARCHING_RAY_COUNT);
	
	float hitDistance = 0.0;
	const float maxDistance = (1.0 / cGridBaseScale * (1 << cascade)) * 4.0;
	vec4 rayHitColor = raymarch(worldSpacePos + dir * 0.11, dir, hitDistance);
	rayHitColor.rgb = rayHitColor.a != 0 ? rayHitColor.rgb : vec3(0.529, 0.808, 0.922);
	
	hitDistance = min(maxDistance, hitDistance);
	
	imageStore(uResultImage, ivec2(gl_LocalInvocationID.x, gl_WorkGroupID.x), vec4(rayHitColor.rgb, 1.0));
	imageStore(uDistanceImage, ivec2(gl_LocalInvocationID.x, gl_WorkGroupID.x), vec4(hitDistance));
}