#version 450

#include "lightIrradianceVolume_bindings.h"
#include "common.h"

layout(set = VOXEL_IMAGE_SET, binding = VOXEL_IMAGE_BINDING) uniform sampler3D uVoxelImage;
layout(set = IRRADIANCE_VOLUME_IMAGE_SET, binding = IRRADIANCE_VOLUME_IMAGE_BINDING, rgba16f) uniform image3D uIrradianceVolumeImages[3];
layout(set = AGE_IMAGE_SET, binding = AGE_IMAGE_BINDING, r8) uniform image3D uAgeImage;

layout(set = QUEUE_BUFFER_SET, binding = QUEUE_BUFFER_BINDING) readonly buffer QUEUE_BUFFER
{
	uint uQueueSize;
	float uP;
	uint uQueue[];
};

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout(constant_id = GRID_WIDTH_CONST_ID) const uint cGridWidth = 64;
layout(constant_id = GRID_HEIGHT_CONST_ID) const uint cGridHeight = 32;
layout(constant_id = GRID_DEPTH_CONST_ID) const uint cGridDepth = 64;
layout(constant_id = CASCADES_CONST_ID) const uint cCascades = 3;
layout(constant_id = GRID_BASE_SCALE_CONST_ID) const float cGridBaseScale = 2.0;
layout(constant_id = VOXEL_GRID_WIDTH_CONST_ID) const uint cVoxelGridWidth = 128;
layout(constant_id = VOXEL_GRID_HEIGHT_CONST_ID) const uint cVoxelGridHeight = 64;
layout(constant_id = VOXEL_GRID_DEPTH_CONST_ID) const uint cVoxelGridDepth = 128;
layout(constant_id = VOXEL_CASCADES_CONST_ID) const uint cVoxelCascades = 3;
layout(constant_id = VOXEL_BASE_SCALE_CONST_ID) const float cVoxelGridBaseScale = 4.0;
layout(constant_id = QUEUE_CAPACITY_CONST_ID) const uint cQueueCapacity = 4096;

shared vec3 sResults[1024];
shared uint sFaces[1024];

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

uint rngState = 0;

uint rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rngState ^= (rngState << 13);
    rngState ^= (rngState >> 17);
    rngState ^= (rngState << 5);
    return rngState;
}

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

vec3 cosineSampleHemisphere(float u1, float u2) 
{
    float r = sqrt(u1);
    float theta = 2 * PI * u2;

    float x = r * cos(theta);
    float z = r * sin(theta);

    return vec3(x, z, sqrt(max(0.0, 1.0 - x * x - z * z)));
}

vec3 uniformSampleSphere(float u1, float u2)
{
	const float phi = 2 * PI * u1;
    const float cosTheta = 1.0 - 2.0 * u2;
	const float sinTheta = 2.0 * sqrt(u2 * (1.0 - u2));
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

//vec3 worldToGrid(vec3 pos, ivec3 gridSize, float baseScale, uint cascade, out ivec3 offset)
//{
//	float scale = (baseScale * (1 << cascade));
//	offset = ivec3(round(uPushConsts.cameraPosition.xyz / scale)) - gridSize / 2;
//	return ivec3(round(pos / scale));
//}
//
//vec3 gridToWorld(vec3 pos, float baseScale, uint cascade)
//{
//	return pos * (baseScale * (1 << cascade));
//}

void main() 
{
	const ivec3 gridSize = ivec3(cGridWidth, cGridHeight, cGridDepth);
	const ivec3 voxelGridSize = ivec3(cVoxelGridWidth, cVoxelGridHeight, cVoxelGridDepth);
	
	rngState = wang_hash(gl_GlobalInvocationID.x * floatBitsToInt(uPushConsts.time));
	
	const float rnd0 = rand_xorshift() * (1.0 / 4294967296.0);
	const float rnd1 = rand_xorshift() * (1.0 / 4294967296.0);
	
	// generate random direction
	const vec3 dir = uniformSampleSphere(rnd0, rnd1);
	
	// get cell index and cascade index
	uint cellIndex = uQueue[gl_WorkGroupID.x];
	const uint cascade = cellIndex / (cGridWidth * cGridHeight * cGridDepth);
	cellIndex -= cascade * (cGridWidth * cGridHeight * cGridDepth);
	
	// get cell coordinate
	ivec3 cellCoord;
	cellCoord.y = int(cellIndex / (gridSize.x * gridSize.z));
	cellCoord.x = int(cellIndex % gridSize.x);
	cellCoord.z = int((cellIndex - cellCoord.y * (gridSize.x * gridSize.z)) / gridSize.x);
	
	ivec3 gridOffset = ivec3(round(uPushConsts.cameraPosition.xyz * (cGridBaseScale / (1 << cascade)))) - gridSize / 2;
	vec3 worldSpacePos = vec3(cellCoord + gridOffset) / (cGridBaseScale / (1 << cascade));
	
	vec3 rayHitColor = vec3(0.0);
	
	uint currentCascade = cascade;
	
	// grid space
	gridOffset = ivec3(round(uPushConsts.cameraPosition.xyz * (cVoxelGridBaseScale / (1 << cascade)))) - voxelGridSize / 2;
	vec3 gridCoord = round(worldSpacePos * (cVoxelGridBaseScale / (1 << cascade)));
	
	const vec3 gridStep = sign(dir);
	const vec3 corner = max(gridStep, vec3(0.0));
	const vec3 invVoxelGridSize = 1.0 / vec3(voxelGridSize);
	
	// ray space
	const vec3 inv = 1.0 / dir;
	vec3 ratio = (gridCoord + corner - gridCoord) * inv;
	const vec3 ratioStep = gridStep * inv;
	
	const int maxSteps = 80;
	int curStep = 0;
	// dda
	while (curStep < maxSteps) 
	{
		// ray is outside of cascade
		if (any(lessThan(gridCoord, gridOffset)) || any(greaterThanEqual(gridCoord, voxelGridSize + gridOffset)))
		{
			rayHitColor = vec3(0.529, 0.808, 0.922);
				break;
			// ray is outside all cascades -> sample sky color
			if (currentCascade == (cVoxelCascades - 1))
			{
				rayHitColor = vec3(0.529, 0.808, 0.922);
				break;
			}
			else
			{
				// go to next cascade
				vec3 worldSpacePos = vec3(cellCoord + gridOffset) / (cVoxelGridBaseScale / (1 << currentCascade));
				++currentCascade;
				gridOffset = ivec3(round(uPushConsts.cameraPosition.xyz * (cVoxelGridBaseScale / (1 << currentCascade)))) - voxelGridSize / 2;
				gridCoord = round(worldSpacePos * (cVoxelGridBaseScale / (1 << currentCascade)));
			}
		}
		
		ivec3 coord = ivec3(fract(gridCoord * invVoxelGridSize) * voxelGridSize);
		// cascades are stacked on top of each other inside the same image
		coord += ivec3(0, currentCascade * cVoxelGridHeight, 0);
		// z and y axis are switched in order to "grow" the image along the z axis with each additional cascade
		coord = coord.xzy;
		
		const vec4 c = texelFetch(uVoxelImage, coord, 0);
		if (c.a > 0.0)
		{
			rayHitColor = c.xyz;
			break;
		}
	
		const ivec3 mask = ivec3(lessThanEqual(ratio.xyz, min(ratio.yzx, ratio.zxy)));
		gridCoord += gridStep  * mask;		
		ratio += ratioStep * mask;
		++curStep;
	}
	
	sResults[gl_LocalInvocationID.x] = rayHitColor;
	vec3 absDir = abs(dir);
	float maxComponent = max(absDir.x, max(absDir.y, absDir.z));
	uint faceIdx = absDir.x == maxComponent ? 0 : absDir.y == maxComponent ? 1 : 2;
	faceIdx += dir[faceIdx] < 0.0 ? 3 : 0;
	sFaces[gl_LocalInvocationID.x] = faceIdx;
	
	barrier();
	
	if (gl_LocalInvocationID.x == 0)
	{
		vec3 accum[6];
		uint counts[6];
		for (uint i = 0; i < 6; ++i)
		{
			accum[i] = vec3(0.0);
			counts[i] = 0;
		}
		for (uint i = 0; i < 1024; ++i)
		{
			uint face = sFaces[i];
			accum[face] += sResults[i];
			++counts[face];
		}
		
		ivec3 gridOffset = ivec3(round(uPushConsts.cameraPosition.xyz * (cGridBaseScale / (1 << cascade)))) - gridSize / 2;
		ivec3 coord = ivec3(fract(vec3(cellCoord + gridOffset) * (1.0 / gridSize)) * gridSize);
		// cascades are stacked on top of each other inside the same image
		coord += ivec3(0, cascade * cGridHeight * 2, 0);
		// z and y axis are switched in order to "grow" the image along the z axis with each additional cascade
		coord = coord.xzy;
		
		float age = imageLoad(uAgeImage, coord - ivec3(0, 0, cascade * cGridHeight * 2) + ivec3(0, 0, cascade * cGridHeight)).x;
		float alpha = 1.0;//age == 0.0 ? 1.0 : age * 0.05;
		
		for (int i = 0; i < 3; ++i)
		{
			vec3 color = imageLoad(uIrradianceVolumeImages[i], coord).rgb;
			imageStore(uIrradianceVolumeImages[i], coord, vec4(mix(color, accum[i] / counts[i], alpha), 1.0));
			
			color = imageLoad(uIrradianceVolumeImages[i], coord + ivec3(0, 0, gridSize.y)).rgb;
			imageStore(uIrradianceVolumeImages[i], coord + ivec3(0, 0, gridSize.y), vec4(mix(color, accum[i + 3] / counts[i + 3], alpha), 1.0));
		}
		
		imageStore(uAgeImage, coord - ivec3(0, 0, cascade * cGridHeight * 2) + ivec3(0, 0, cascade * cGridHeight), vec4(1.0 / 256.0));
	}
}