#version 450

#ifndef SSAO_ENABLED
#define SSAO_ENABLED 0
#endif // SSAO_ENABLED

#include "indirectDiffuse_bindings.h"
#include "common.h"

layout(constant_id = WIDTH_CONST_ID) const uint cWidth = 1600;
layout(constant_id = HEIGHT_CONST_ID) const uint cHeight = 900;
layout(constant_id = TEXEL_WIDTH_CONST_ID) const float cTexelWidth = 1.0 / 1600.0;
layout(constant_id = TEXEL_HEIGHT_CONST_ID) const float cTexelHeight = 1.0 / 900;
layout(constant_id = IRRADIANCE_VOLUME_WIDTH_CONST_ID) const uint cGridWidth = 64;
layout(constant_id = IRRADIANCE_VOLUME_HEIGHT_CONST_ID) const uint cGridHeight = 32;
layout(constant_id = IRRADIANCE_VOLUME_DEPTH_CONST_ID) const uint cGridDepth = 64;
layout(constant_id = IRRADIANCE_VOLUME_CASCADES_CONST_ID) const uint cCascades = 3;
layout(constant_id = IRRADIANCE_VOLUME_BASE_SCALE_CONST_ID) const float cGridBaseScale = 2.0;
layout(constant_id = IRRADIANCE_VOLUME_PROBE_SIDE_LENGTH_CONST_ID) const uint cProbeSideLength = 8;
layout(constant_id = IRRADIANCE_VOLUME_DEPTH_PROBE_SIDE_LENGTH_CONST_ID) const uint cDepthProbeSideLength = 16;

layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING, rgba16f) uniform image2D uResultImage;
layout(set = DEPTH_IMAGE_SET, binding = DEPTH_IMAGE_BINDING) uniform sampler2D uDepthImage;
layout(set = ALBEDO_IMAGE_SET, binding = ALBEDO_IMAGE_BINDING) uniform sampler2D uAlbedoImage;
layout(set = NORMAL_IMAGE_SET, binding = NORMAL_IMAGE_BINDING) uniform sampler2D uNormalImage;
layout(set = IRRADIANCE_VOLUME_IMAGE_SET, binding = IRRADIANCE_VOLUME_IMAGE_BINDING) uniform sampler2D uIrradianceVolumeImage;
layout(set = IRRADIANCE_VOLUME_DEPTH_IMAGE_SET, binding = IRRADIANCE_VOLUME_DEPTH_IMAGE_BINDING) uniform sampler2D uIrradianceVolumeDepthImage;
#if SSAO_ENABLED
layout(set = OCCLUSION_IMAGE_SET, binding = OCCLUSION_IMAGE_BINDING) uniform sampler2D uOcclusionImage;
#endif // SSAO_ENABLED

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

float signNotZero(in float k) 
{
    return k >= 0.0 ? 1.0 : -1.0;
}

vec2 signNotZero(in vec2 v) 
{
    return vec2( signNotZero(v.x), signNotZero(v.y) );
}

float square(float v)
{
	return v * v;
}

vec2 octEncode(in vec3 v) 
{
    float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
    vec2 result = v.xy * (1.0/l1norm);
    if (v.z < 0.0) 
	{
        result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
    }
    return result;
}

vec2 texCoordFromDir(vec3 dir, ivec3 probeCoord, int cascade, int probeSideLength)
{
	vec2 texelCoord = vec2((ivec2(cGridWidth, cGridDepth) * ivec2(probeCoord.y, cascade) + probeCoord.xz) * (probeSideLength + 2)) + 1.0;
	texelCoord += (octEncode(dir) * 0.5 + 0.5) * float(probeSideLength);
	const vec2 texelSize = 1.0 / vec2(ivec2(cGridWidth, cGridDepth) * ivec2(cGridHeight, cCascades) * ivec2(probeSideLength + 2));
	return texelCoord  * texelSize;
}

vec3 sampleIrradianceVolumeCascade(const vec3 worldSpacePos, const vec3 worldSpaceNormal, const vec3 worldSpaceViewDir, const int cascade)
{
	vec4 sum = vec4(0.0);
	for (int i = 0; i < 8; ++i)
	{
		vec3 pointGridCoord = worldSpacePos * (cGridBaseScale / (1 << cascade));
		vec3 probeGridCoord = floor(pointGridCoord) + (ivec3(i, i >> 1, i >> 2) & ivec3(1));
		vec3 trilinear =  1.0 - abs(probeGridCoord - pointGridCoord);
		float weight = 1.0;
		
		const vec3 trueDirToProbe = probeGridCoord - pointGridCoord;
		const bool probeInPoint = dot(trueDirToProbe, trueDirToProbe) < 1e-6;
		
		// smooth backface test
		{
			weight *= probeInPoint ? 1.0 : square(max(0.0001, (dot(normalize(trueDirToProbe), worldSpaceNormal) + 1.0) * 0.5)) + 0.2;
		}
		
		const vec3 gridSize = vec3(cGridWidth, cGridHeight, cGridDepth);
		const ivec3 wrappedProbeGridCoord = ivec3(fract(probeGridCoord / vec3(gridSize)) * gridSize);
		
		// moment visibility test
		if (!probeInPoint)
		{
			vec3 worldSpaceProbePos = probeGridCoord * (cGridBaseScale * (1 << cascade));
			vec3 biasedProbeToPoint = worldSpacePos - worldSpaceProbePos + (worldSpaceNormal + 3.0 * worldSpaceViewDir) * 0.3;
			vec3 dir = normalize(biasedProbeToPoint);
			vec2 texCoord = texCoordFromDir(dir, wrappedProbeGridCoord, int(cascade), int(cDepthProbeSideLength));
			float distToProbe = length(biasedProbeToPoint) + 0.12;
			
			vec2 temp = textureLod(uIrradianceVolumeDepthImage, texCoord, 0).xy;
			float mean = temp.x;
			float variance = abs(temp.x * temp.x - temp.y);
			
			float chebyshevWeight = variance / (variance + square(max(distToProbe - mean, 0.0)));
			
			chebyshevWeight = max(chebyshevWeight * chebyshevWeight * chebyshevWeight, 0.0);
			
			weight *= (distToProbe <= mean) ? 1.0 : chebyshevWeight;
		}
		
		// avoid zero weight
		weight = max(0.000001, weight);
		
		const float crushThreshold = 0.2;
		if (weight < crushThreshold)
		{
			weight *= weight * weight * (1.0 / square(crushThreshold));
		}
		
		// trilinear
		weight *= trilinear.x * trilinear.y * trilinear.z;
		
		vec2 probeTexCoord = texCoordFromDir(worldSpaceNormal, wrappedProbeGridCoord, int(cascade), int(cProbeSideLength));
		vec3 probeIrradiance = textureLod(uIrradianceVolumeImage, probeTexCoord, 0).rgb;
		
		probeIrradiance = sqrt(probeIrradiance);
		
		sum += vec4(probeIrradiance * weight, weight);
	}
	vec3 irradiance = sum.xyz / sum.w;
	
	return irradiance * irradiance;
}

vec3 sampleIrradianceVolume(const vec3 viewSpacePos, const vec3 viewSpaceNormal)
{
	mat4 invViewMatrix = transpose(mat4(uPushConsts.invViewMatrixRow0, uPushConsts.invViewMatrixRow1, uPushConsts.invViewMatrixRow2, vec4(0.0, 0.0, 0.0, 1.0)));
	vec4 worldSpacePos4 = invViewMatrix * vec4(viewSpacePos, 1.0);
	vec3 worldSpacePos = worldSpacePos4.xyz / worldSpacePos4.w;
	vec3 worldSpaceNormal = (invViewMatrix * vec4(viewSpaceNormal, 0.0)).xyz;
	vec3 worldSpaceViewDir = normalize(invViewMatrix[3].xyz - worldSpacePos);
	vec3 camPos = invViewMatrix[3].xyz;
	const ivec3 gridSize = ivec3(cGridWidth, cGridHeight, cGridDepth);
	float currentGridScale = cGridBaseScale;
	int cascadeIndex = 0;
	float cascadeWeight = 0.0;
	
	// search for cascade index
	for (; cascadeIndex < cCascades; ++cascadeIndex)
	{
		// calculate coordinate in world space fixed coordinate system (scaled to voxel size)
		vec3 gridPos = worldSpacePos * currentGridScale;
		vec3 offset = round(camPos * currentGridScale) - (gridSize / 2);

		// if coordinate is inside grid, we found the correct cascade
		if (all(greaterThanEqual(gridPos, offset)) && all(lessThan(gridPos, gridSize + offset - 1.0)))
		{
			const float falloffStart = 0.25;
			vec3 smoothOffset = camPos * currentGridScale - (gridSize / 2) - 0.5;
			vec3 relativeCoord = clamp(abs(((gridPos - smoothOffset) / vec3(gridSize)) * 2.0 - 1.0), 0.0, 1.0);
			float minDistToBorder = 1.0 - max(relativeCoord.x, max(relativeCoord.y, relativeCoord.z));
			cascadeWeight = minDistToBorder < falloffStart ? smoothstep(0.0, 1.0, minDistToBorder * (1.0 / falloffStart)) : 1.0;
			break;
		}
		currentGridScale *= 0.5;
	}
	
	if (cascadeIndex < cCascades)
	{
		vec3 irradiance = sampleIrradianceVolumeCascade(worldSpacePos, worldSpaceNormal, worldSpaceViewDir, cascadeIndex);
		if (cascadeWeight < 1.0)
		{
			vec3 irradiance2 = vec3(0.18);
			if ((cascadeIndex + 1) < cCascades)
			{
				irradiance2 = sampleIrradianceVolumeCascade(worldSpacePos, worldSpaceNormal, worldSpaceViewDir, cascadeIndex + 1);
			}
			irradiance = mix(irradiance2, irradiance, cascadeWeight);
		}
		return irradiance;
	}
	return vec3(0.18);
}

vec3 accurateSRGBToLinear(in vec3 sRGBCol)
{
	vec3 linearRGBLo = sRGBCol * (1.0 / 12.92);
	vec3 linearRGBHi = pow((sRGBCol + vec3(0.055)) * vec3(1.0 / 1.055), vec3(2.4));
	vec3 linearRGB = mix(linearRGBLo, linearRGBHi, vec3(greaterThan(sRGBCol, vec3(0.04045))));
	return linearRGB;
}

void main() 
{
	if (gl_GlobalInvocationID.x >= cWidth || gl_GlobalInvocationID.y >= cHeight)
	{
		return;
	}
	const float depth = texelFetch(uDepthImage, ivec2(gl_GlobalInvocationID.xy), 0).x;
	
	if (depth == 0.0)
	{
		return;
	}

	// view space position
	const vec4 clipSpacePosition = vec4(vec2(gl_GlobalInvocationID.xy + 0.5) * vec2(cTexelWidth, cTexelHeight)  * 2.0 - 1.0, depth, 1.0);
	vec4 viewSpacePosition4 = uPushConsts.invJitteredProjectionMatrix * clipSpacePosition;
	const vec3 viewSpacePos = viewSpacePosition4.xyz / viewSpacePosition4.w;
	const vec3 N = texelFetch(uNormalImage, ivec2(gl_GlobalInvocationID.xy), 0).xyz;
	
	vec3 irradiance = sampleIrradianceVolume(viewSpacePos, N) * (1.0 / PI);
	irradiance *= accurateSRGBToLinear(texelFetch(uAlbedoImage, ivec2(gl_GlobalInvocationID.xy), 0).rgb);
#if SSAO_ENABLED
	irradiance *=  texelFetch(uOcclusionImage, ivec2(gl_GlobalInvocationID.xy), 0).x;
#endif // SSAO_ENABLED
	
	const vec3 lit = imageLoad(uResultImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
	imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(irradiance + lit, 1.0));
}