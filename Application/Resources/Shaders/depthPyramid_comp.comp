#version 450

#include "depthPyramid_bindings.h"

layout(set = INPUT_IMAGE_SET, binding = INPUT_IMAGE_BINDING) uniform sampler2D uInputImage;
layout(set = RESULT_IMAGE_SET, binding = RESULT_IMAGE_BINDING, r32f) uniform writeonly image2D uResultImage;


layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PUSH_CONSTS 
{
	PushConsts uPushConsts;
};

void main() 
{
	if (gl_GlobalInvocationID.x < uPushConsts.width && gl_GlobalInvocationID.y < uPushConsts.height)
	{
		// get integer pixel coordinates
		ivec2 coords = ivec2(gl_GlobalInvocationID.xy) * 2;
		
		// fetch a 2x2 neighborhood and compute the furthest depth
		vec4 depths;
		depths[0] = texelFetch(uInputImage, coords + ivec2(0, 0), 0).x;
		depths[1] = texelFetch(uInputImage, coords + ivec2(1, 0), 0).x;
		depths[2] = texelFetch(uInputImage, coords + ivec2(0, 1), 0).x;
		depths[3] = texelFetch(uInputImage, coords + ivec2(1, 1), 0).x;
		
		float minDepth = min(min(depths[0], depths[1]), min(depths[2], depths[3]));
		
		const ivec2 prevMipSize = uPushConsts.prevMipSize;
		
		// if we are reducing an odd-sized texture,
		// then the edge pixels need to fetch additional texels
		vec2 extra;
		if (((prevMipSize.x & 1) == 1) && (coords.x == (prevMipSize.x - 3)))
		{
			extra[0] = texelFetch(uInputImage, coords + ivec2(2, 0), 0).x;
			extra[1] = texelFetch(uInputImage, coords + ivec2(2, 1), 0).x;
			minDepth = min(minDepth, min(extra[0], extra[1]));
		}
		
		if (((prevMipSize.y & 1) == 1) && (coords.y == (prevMipSize.y - 3)))
		{
			extra[0] = texelFetch(uInputImage, coords + ivec2(0, 2), 0).x;
			extra[1] = texelFetch(uInputImage, coords + ivec2(1, 2), 0).x;
			minDepth = min(minDepth, min(extra[0], extra[1]));
		}
		
		// extreme case: if both edges are odd, fetch the bottom-right corner
		if (((prevMipSize.x & 1) == 1) && ((prevMipSize.y & 1) == 1)
			&& (coords.x == (prevMipSize.x - 3)) && (coords.y == (prevMipSize.y - 3)))
		{
			minDepth = min(minDepth, texelFetch(uInputImage, coords + ivec2(2, 2), 0).x);
		}
		
		imageStore(uResultImage, ivec2(gl_GlobalInvocationID.xy), vec4(minDepth));
	}
}